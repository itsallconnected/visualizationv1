<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Alignment 3D Visualization</title>
    <!-- Google Fonts - Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- TWEEN.js for smooth animations -->
    <script src="https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@18.6.4/dist/tween.umd.js"></script>
    <link rel="stylesheet" href="/static/style.css">
</head>
<body>
    <div class="container">
        <div id="visualization-container">
            <div id="scene-container"></div>
            <div id="node-labels-container"></div>
            <div class="controls">
                <button id="zoom-in">Zoom In</button>
                <button id="zoom-out">Zoom Out</button>
                <button id="reset-view">Reset View</button>
                <button id="toggle-rotation">Toggle Rotation</button>
            </div>
            <div class="legend">
                <h3>Node Types</h3>
                <div class="legend-item">
                    <span class="legend-color component-group"></span>
                    <span>Component Group</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color component"></span>
                    <span>Component</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color subcomponent"></span>
                    <span>Subcomponent</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color capability"></span>
                    <span>Capability</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color function"></span>
                    <span>Function</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color specification"></span>
                    <span>Specification</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color integration"></span>
                    <span>Integration</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color technique"></span>
                    <span>Technique</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color application"></span>
                    <span>Application</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color input"></span>
                    <span>Input</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color output"></span>
                    <span>Output</span>
                </div>
            </div>
        </div>
        <div id="details-panel">
            <div class="details-header">
                <h2 id="details-title">Select a node to view details</h2>
                <div id="breadcrumb-navigation" class="breadcrumb-container"></div>
            </div>
            <div id="details-content" class="scrollable-content"></div>
            <div id="literature-references" class="literature-section">
                <h3>Literature References</h3>
                <div id="references-content"></div>
            </div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.150.1/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { DragControls } from 'three/addons/controls/DragControls.js';
        
        class AIAlignmentVisualization {
            constructor() {
                // Core properties
                this.container = document.getElementById('scene-container');
                this.labelsContainer = document.getElementById('node-labels-container');
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;
                this.dragControls = null;
                this.raycaster = null;
                this.mouse = null;
                this.graphData = null;
                
                // Node handling
                this.nodes = new Map(); // Map of node ID to Three.js object
                this.links = new Map(); // Map of link ID to Three.js object
                this.nodeOrbits = new Map(); // Map of node ID to its orbital info
                this.nodePositions = new Map(); // Map of node ID to position
                this.nodeDetails = new Map(); // Map of node ID to its data
                this.textLabels = new Map(); // Map of node ID to its text sprite
                this.selectedNode = null;
                this.expandedNodes = new Set();
                this.isRotating = false;
                this.isDragging = false;
                this.clock = new THREE.Clock();
                
                // Initialize
                this.init();
                this.setupEventListeners();
                this.loadData();
            }
            
            init() {
                const width = this.container.clientWidth;
                const height = this.container.clientHeight;
                
                // Scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x0f1015);
                
                // Camera
                this.camera = new THREE.PerspectiveCamera(60, width/height, 0.1, 10000);
                this.camera.position.z = 800;
                
                // Renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(width, height);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.container.appendChild(this.renderer.domElement);
                
                // Wait for fonts to load before starting
                document.fonts.ready.then(() => {
                    console.log("Fonts loaded successfully");
                }).catch(err => {
                    console.error("Font loading issue:", err);
                });
                
                // Controls - Using OrbitControls with ES modules
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.25;
                
                // Raycaster for interaction
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                
                // Ambient light
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                this.scene.add(ambientLight);
                
                // Directional light
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
                directionalLight.position.set(1, 1, 1);
                this.scene.add(directionalLight);
                
                // Additional lights for better sphere visibility
                const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight2.position.set(-1, -1, -1);
                this.scene.add(directionalLight2);
                
                const pointLight = new THREE.PointLight(0xffffff, 0.5);
                pointLight.position.set(0, 0, 500);
                this.scene.add(pointLight);
                
                // Start animation loop
                this.animate();
                
                // Handle window resize
                window.addEventListener('resize', () => this.onWindowResize());
                
                // Internal flags for throttling operations
                this._processingSelection = false;
                this._processingExpansion = false;
                this._lastOrbitUpdate = null;
            }
            
            setupEventListeners() {
                // Mouse interaction
                this.container.addEventListener('mousemove', (event) => this.onMouseMove(event));
                this.container.addEventListener('click', (event) => this.onClick(event));
                
                // Control buttons
                document.getElementById('zoom-in').addEventListener('click', () => this.zoomIn());
                document.getElementById('zoom-out').addEventListener('click', () => this.zoomOut());
                document.getElementById('reset-view').addEventListener('click', () => this.resetView());
                document.getElementById('toggle-rotation').addEventListener('click', () => this.toggleRotation());
                
                // Add hover event listener for node names
                this.container.addEventListener('mousemove', (event) => {
                    if (this._processingSelection) return;
                    this._processingSelection = true;
                    
                    // Calculate mouse position in normalized device coordinates
                    const rect = this.container.getBoundingClientRect();
                    this.mouse.x = ((event.clientX - rect.left) / this.container.clientWidth) * 2 - 1;
                    this.mouse.y = -((event.clientY - rect.top) / this.container.clientHeight) * 2 + 1;
                    
                    // Update the picking ray with the camera and mouse position
                    this.raycaster.setFromCamera(this.mouse, this.camera);
                    
                    // Calculate objects intersecting the picking ray
                    const intersects = this.raycaster.intersectObjects(Array.from(this.nodes.values()));
                    
                    // Display node name in top right corner
                    const nameDisplay = document.getElementById('hover-node-name') || this.createHoverNameDisplay();
                    
                    if (intersects.length > 0) {
                        // Show label for hovered node
                        const hoveredNode = intersects[0].object;
                        const nodeName = hoveredNode.userData.node.name;
                        const nodeType = hoveredNode.userData.node.type.replace('_', ' ');
                        
                        nameDisplay.innerHTML = `
                            <div class="node-type">${this.capitalizeFirstLetter(nodeType)}</div>
                            <div class="node-name">${nodeName}</div>
                        `;
                        nameDisplay.style.opacity = '1';
                        
                        // Show the text sprite for this node
                        const nodeId = hoveredNode.userData.node.id;
                        if (this.textLabels.has(nodeId)) {
                            const textLabel = this.textLabels.get(nodeId);
                            textLabel.material.opacity = 1;
                        }
                    } else {
                        // Hide hover display when not hovering over a node
                        nameDisplay.style.opacity = '0';
                        
                        // Hide all text labels
                        for (const label of this.textLabels.values()) {
                            label.material.opacity = 0;
                        }
                    }
                    
                    this._processingSelection = false;
                });
            }
            
            loadData() {
                fetch('/api/graph')
                    .then(response => response.json())
                    .then(data => {
                        this.graphData = this.processGraphData(data);
                        this.initializeGraph();
                    })
                    .catch(error => console.error('Error loading graph data:', error));
            }
            
            processGraphData(data) {
                // Create a map of all nodes by ID for easier access
                const nodeMap = new Map();
                data.nodes.forEach(node => {
                    nodeMap.set(node.id, node);
                    node.children = [];
                });
                
                // Set up parent-child relationships
                data.nodes.forEach(node => {
                    if (node.parent) {
                        const parent = nodeMap.get(node.parent);
                        if (parent) {
                            parent.children.push(node);
                        }
                    }
                });
                
                // Store node details
                data.nodes.forEach(node => {
                    this.nodeDetails.set(node.id, node);
                });
                
                return data;
            }
            
            initializeGraph() {
                // Start with just the root node expanded
                const rootNode = this.graphData.nodes.find(node => node.type === 'component_group');
                if (rootNode) {
                    this.expandedNodes.add(rootNode.id);
                    
                    // Get all visible nodes and links
                    const visibleNodes = this.getVisibleNodes();
                    const visibleLinks = this.getVisibleLinks(visibleNodes);
                    
                    // Position nodes in a hierarchical structure
                    this.positionNodes(visibleNodes);
                    
                    // Create visual elements
                    this.createNodeObjects(visibleNodes);
                    this.createLinkObjects(visibleLinks);
                    this.setupNodeOrbits(visibleNodes);
                    this.setupDragControls();
                    
                    // Add a small delay to ensure everything is properly rendered
                    setTimeout(() => {
                        this.updateNodeLabels();
                        
                        // Auto-select the root node to show its details
                        this.selectNode(rootNode);
                    }, 500);
                } else {
                    console.error("No root node found");
                }
            }
            
            positionNodes(nodes) {
                // Position the root node at the center
                const rootNode = nodes.find(node => !node.parent);
                if (rootNode) {
                    this.nodePositions.set(rootNode.id, { x: 0, y: 0, z: 0 });
                }
                
                // Group nodes by level for hierarchical layout
                const nodesByLevel = {};
                for (const node of nodes) {
                    if (!nodesByLevel[node.level]) {
                        nodesByLevel[node.level] = [];
                    }
                    nodesByLevel[node.level].push(node);
                }
                
                // Position child nodes around their parents
                for (let level = 1; level <= 4; level++) { // Support up to 4 levels (adjust if needed)
                    if (!nodesByLevel[level]) continue;
                    
                    const levelNodes = nodesByLevel[level];
                    const parentGroups = this.groupBy(levelNodes, 'parent');
                    
                    for (const [parentId, children] of Object.entries(parentGroups)) {
                        const parentPos = this.nodePositions.get(parentId);
                        if (!parentPos) continue;
                        
                        // Position children in a spherical arrangement around parent
                        const numChildren = children.length;
                        
                        // Adjust orbit radius based on level
                        let radius;
                        switch (level) {
                            case 1: radius = 200; break; // Components around component group
                            case 2: radius = 150; break; // Subcomponents around components
                            case 3: radius = 100; break; // Capabilities around subcomponents
                            case 4: radius = 80; break;  // Functions around capabilities
                            default: radius = 120;
                        }
                        
                        children.forEach((node, index) => {
                            // Calculate position on a sphere around parent
                            const phi = Math.acos(-1 + (2 * index) / Math.max(1, numChildren));
                            const theta = Math.sqrt(Math.max(1, numChildren) * Math.PI) * phi;
                            
                            const x = parentPos.x + radius * Math.sin(phi) * Math.cos(theta);
                            const y = parentPos.y + radius * Math.sin(phi) * Math.sin(theta);
                            const z = parentPos.z + radius * Math.cos(phi);
                            
                            this.nodePositions.set(node.id, { x, y, z });
                        });
                    }
                }
            }
            
            groupBy(array, key) {
                return array.reduce((result, item) => {
                    const groupKey = item[key];
                    if (!result[groupKey]) {
                        result[groupKey] = [];
                    }
                    result[groupKey].push(item);
                    return result;
                }, {});
            }
            
            getVisibleNodes() {
                // Start with nodes that have no parent (root nodes)
                let visibleNodes = this.graphData.nodes.filter(node => !node.parent);
                
                // Add nodes whose parents are expanded
                const expandedParents = new Set(Array.from(this.expandedNodes));
                
                // Process each level to ensure hierarchical visibility
                for (let level = 1; level <= 10; level++) { // Support up to 10 levels for deeper hierarchies
                    const levelNodes = this.graphData.nodes.filter(node => 
                        node.level === level && 
                        expandedParents.has(node.parent)
                    );
                    
                    visibleNodes = visibleNodes.concat(levelNodes);
                    
                    // Add expanded nodes from this level to expanded parents for next level
                    levelNodes.forEach(node => {
                        if (this.expandedNodes.has(node.id)) {
                            expandedParents.add(node.id);
                        }
                    });

                    // Break if we didn't find any nodes at this level
                    if (levelNodes.length === 0) {
                        break;
                    }
                }
                
                return visibleNodes;
            }
            
            getVisibleLinks(visibleNodes) {
                const nodeIds = new Set(visibleNodes.map(node => node.id));
                return this.graphData.links.filter(link => 
                    nodeIds.has(link.source) && nodeIds.has(link.target));
            }
            
            createTextureForNode(text, color) {
                // Create a canvas to draw text
                const canvas = document.createElement('canvas');
                const size = 512; // Larger canvas for higher resolution
                canvas.width = size;
                canvas.height = size;
                
                const context = canvas.getContext('2d');
                
                // Create gradient background matching the node color
                const gradient = context.createRadialGradient(
                    size/2, size/2, 0,
                    size/2, size/2, size/2
                );
                
                // Convert hex color to RGB for gradient
                const r = parseInt(color.substring(1, 3), 16);
                const g = parseInt(color.substring(3, 5), 16);
                const b = parseInt(color.substring(5, 7), 16);
                
                gradient.addColorStop(0, `rgb(${r+40}, ${g+40}, ${b+40})`);
                gradient.addColorStop(0.7, color);
                gradient.addColorStop(1, `rgb(${Math.max(0, r-40)}, ${Math.max(0, g-40)}, ${Math.max(0, b-40)})`);
                
                // Fill background with gradient
                context.fillStyle = gradient;
                context.fillRect(0, 0, size, size);
                
                // No text on orbs anymore - we'll rely on hover display
                
                // Create texture from canvas
                const texture = new THREE.CanvasTexture(canvas);
                texture.needsUpdate = true;
                return texture;
            }
            
            createNodeObjects(nodes) {
                // Clear existing nodes
                for (const [id, object] of this.nodes.entries()) {
                    this.scene.remove(object);
                }
                for (const [id, label] of this.textLabels.entries()) {
                    this.scene.remove(label);
                }
                
                this.nodes.clear();
                this.textLabels.clear();
                
                // Create new node objects
                for (const node of nodes) {
                    // Create sphere geometry based on node type
                    const size = this.getNodeSize(node.type);
                    const geometry = new THREE.SphereGeometry(size, 32, 32);
                    
                    // Create material based on node type with text texture
                    const color = this.getNodeColor(node.type);
                    const texture = this.createTextureForNode(node.name, color);
                    
                    const material = new THREE.MeshPhongMaterial({
                        map: texture,
                        color: 0xffffff, // Set to white to show texture colors
                        shininess: 80,
                        transparent: false, // Solid orbs, not transparent
                        opacity: 1.0
                    });
                    
                    // Create mesh
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.userData = { 
                        node,
                        isOrbitTarget: this.expandedNodes.has(node.id),
                        isFixed: this.selectedNode && this.selectedNode.id === node.id // Preserve selected node state
                    };
                    
                    // Position the node
                    if (this.nodePositions.has(node.id)) {
                        const pos = this.nodePositions.get(node.id);
                        mesh.position.set(pos.x, pos.y, pos.z);
                    } else {
                        // Fallback position
                        mesh.position.set(
                            (Math.random() - 0.5) * 200,
                            (Math.random() - 0.5) * 200,
                            (Math.random() - 0.5) * 200
                        );
                        
                        // Store new position
                        this.nodePositions.set(node.id, {
                            x: mesh.position.x,
                            y: mesh.position.y,
                            z: mesh.position.z
                        });
                    }
                    
                    // Create a separate text label that always faces the camera
                    const textSprite = this.createTextSprite(node.name);
                    textSprite.position.copy(mesh.position);
                    textSprite.position.y += size + 20; // Position above sphere with more space
                    
                    // Add to scene
                    this.scene.add(mesh);
                    this.scene.add(textSprite);
                    
                    // Store references
                    this.nodes.set(node.id, mesh);
                    this.textLabels.set(node.id, textSprite);
                }
            }
            
            createTextSprite(text) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                
                // Draw transparent background with rounded corners
                context.fillStyle = 'rgba(30, 30, 50, 0.9)';
                context.beginPath();
                context.roundRect(0, 0, canvas.width, canvas.height, 10);
                context.fill();
                
                // Add a border
                context.strokeStyle = 'rgba(200, 200, 255, 0.9)';
                context.lineWidth = 2;
                context.beginPath();
                context.roundRect(0, 0, canvas.width, canvas.height, 10);
                context.stroke();
                
                // Load fonts before drawing text
                document.fonts.ready.then(() => {
                    // Draw text
                    context.font = 'bold 20px Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                    context.fillStyle = 'white';
                    context.textAlign = 'center';
                    context.textBaseline = 'middle';
                    
                    // Handle text that's too long
                    if (text.length > 24) {
                        const truncated = text.substring(0, 21) + '...';
                        context.fillText(truncated, canvas.width / 2, canvas.height / 2);
                    } else {
                        context.fillText(text, canvas.width / 2, canvas.height / 2);
                    }
                    
                    // Update texture after drawing text
                    texture.needsUpdate = true;
                });
                
                // Create sprite
                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.SpriteMaterial({ 
                    map: texture,
                    transparent: true,
                    opacity: 0.9 // Make labels more visible by default
                });
                const sprite = new THREE.Sprite(material);
                sprite.scale.set(50, 20, 1); // Larger text sprite for better visibility
                
                return sprite;
            }
            
            createLinkObjects(links) {
                // Clear existing links
                for (const [id, object] of this.links.entries()) {
                    this.scene.remove(object);
                }
                this.links.clear();
                
                // Create new link objects
                for (const link of links) {
                    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                    const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                    const linkId = `${sourceId}-${targetId}`;
                    
                    const material = new THREE.LineBasicMaterial({
                        color: this.getLinkColor(link.type),
                        transparent: false,
                        opacity: 1.0,
                        linewidth: 3
                    });
                    
                    // Create line geometry
                    const geometry = new THREE.BufferGeometry();
                    const points = [
                        new THREE.Vector3(0, 0, 0),
                        new THREE.Vector3(0, 0, 0)
                    ];
                    geometry.setFromPoints(points);
                    
                    // Create line
                    const line = new THREE.Line(geometry, material);
                    line.userData = { 
                        link,
                        sourceId,
                        targetId
                    };
                    
                    // Add to scene
                    this.scene.add(line);
                    this.links.set(linkId, line);
                }
                
                // Update link positions
                this.updateLinkPositions();
            }
            
            updateLinkPositions() {
                for (const [id, line] of this.links.entries()) {
                    const { sourceId, targetId } = line.userData;
                    
                    const sourceNode = this.nodes.get(sourceId);
                    const targetNode = this.nodes.get(targetId);
                    
                    if (sourceNode && targetNode) {
                        const points = [
                            sourceNode.position.clone(),
                            targetNode.position.clone()
                        ];
                        line.geometry.setFromPoints(points);
                        line.geometry.attributes.position.needsUpdate = true;
                    }
                }
            }
            
            setupNodeOrbits(nodes) {
                this.nodeOrbits.clear();
                
                // Setup orbital patterns for child nodes around their parents
                for (const node of nodes) {
                    if (!node.parent || !this.expandedNodes.has(node.parent)) continue;
                    
                    const parentNode = this.nodes.get(node.parent);
                    if (!parentNode) continue;
                    
                    // Set up orbital data
                    const orbitData = {
                        center: parentNode.position.clone(),
                        radius: this.getOrbitRadius(node.level),
                        speed: 0.1 + (Math.random() * 0.1), // Random speed variation
                        angle: Math.random() * Math.PI * 2, // Random starting angle
                        axis: new THREE.Vector3(
                            Math.random() - 0.5,
                            Math.random() - 0.5,
                            Math.random() - 0.5
                        ).normalize()
                    };
                    
                    this.nodeOrbits.set(node.id, orbitData);
                }
            }
            
            getOrbitRadius(level) {
                // Different orbit radius based on hierarchy level
                switch (level) {
                    case 1: return 200; // Components around component group
                    case 2: return 150; // Subcomponents around components
                    case 3: return 100; // Capabilities around subcomponents
                    case 4: return 80;  // Functions around capabilities
                    case 5: return 65;  // Specifications around functions
                    case 6: return 55;  // Integration around specifications
                    case 7: return 50;  // Techniques around integration
                    case 8: return 45;  // Applications around techniques
                    case 9: return 40;  // Inputs/Outputs around applications
                    default: return 60;
                }
            }
            
            getNodeSize(nodeType) {
                // Adjust node size based on type
                switch (nodeType) {
                    case 'component_group': return 40;
                    case 'component': return 30;
                    case 'subcomponent': return 22;
                    case 'capability': return 18;
                    case 'function': return 14;
                    case 'specification': return 12;
                    case 'integration': return 10;
                    case 'technique': return 9;
                    case 'application': return 8;
                    case 'input': return 7;
                    case 'output': return 7;
                    default: return 10;
                }
            }
            
            getNodeColor(nodeType, isSelected = false) {
                // Base colors for different node types
                const baseColors = {
                    'component_group': '#3498db', // Blue
                    'component': '#2ecc71',       // Green
                    'subcomponent': '#e74c3c',    // Red
                    'capability': '#f39c12',      // Orange
                    'function': '#9b59b6',        // Purple
                    'specification': '#1abc9c',   // Turquoise
                    'integration': '#34495e',     // Dark Blue
                    'technique': '#d35400',       // Dark Orange
                    'application': '#27ae60',     // Dark Green
                    'input': '#8e44ad',           // Dark Purple
                    'output': '#16a085'           // Dark Turquoise
                };
                
                // Selected state colors (brighter)
                const selectedColors = {
                    'component_group': '#5dade2', // Lighter Blue
                    'component': '#58d68d',       // Lighter Green
                    'subcomponent': '#ec7063',    // Lighter Red
                    'capability': '#f5b041',      // Lighter Orange
                    'function': '#bb8fce',        // Lighter Purple
                    'specification': '#48c9b0',   // Lighter Turquoise
                    'integration': '#5d6d7e',     // Lighter Dark Blue
                    'technique': '#e67e22',       // Lighter Dark Orange
                    'application': '#2ecc71',     // Lighter Dark Green
                    'input': '#9b59b6',           // Lighter Dark Purple
                    'output': '#1abc9c'           // Lighter Dark Turquoise
                };
                
                const colorMap = isSelected ? selectedColors : baseColors;
                return colorMap[nodeType] || '#95a5a6'; // Default gray
            }
            
            getLinkColor(linkType) {
                switch (linkType) {
                    case 'contains': return 0xaed6f1;
                    case 'has_capability': return 0xf9e79f;
                    case 'has_function': return 0xd2b4de;
                    case 'has_specification': return 0xabebc6;
                    case 'has_integration': return 0x85c1e9;
                    case 'has_technique': return 0xf5cba7;
                    case 'has_application': return 0xa2d9ce;
                    case 'has_input': return 0xbb8fce;
                    case 'has_output': return 0x7dcea0;
                    default: return 0xbdc3c7;
                }
            }
            
            updateNodePositions() {
                if (!this.isRotating) return;
                
                const deltaTime = this.clock.getDelta();
                
                // Update positions for orbiting nodes
                for (const [nodeId, orbitData] of this.nodeOrbits.entries()) {
                    const node = this.nodes.get(nodeId);
                    if (!node || node.userData.isFixed) continue;
                    
                    // Update orbit angle
                    orbitData.angle += orbitData.speed * deltaTime;
                    
                    // Create rotation quaternion around the orbit axis
                    const rotationQuat = new THREE.Quaternion();
                    rotationQuat.setFromAxisAngle(orbitData.axis, orbitData.angle);
                    
                    // Create position vector along the orbital plane
                    const position = new THREE.Vector3(orbitData.radius, 0, 0);
                    position.applyQuaternion(rotationQuat);
                    position.add(orbitData.center);
                    
                    // Update node position
                    node.position.copy(position);
                    
                    // Update node's stored position
                    this.nodePositions.set(nodeId, {
                        x: position.x,
                        y: position.y,
                        z: position.z
                    });
                    
                    // Update text label position
                    if (this.textLabels.has(nodeId)) {
                        const textLabel = this.textLabels.get(nodeId);
                        textLabel.position.copy(position);
                        textLabel.position.y += this.getNodeSize(node.userData.node.type) + 20;
                    }
                }
                
                // Update positions for links
                this.updateLinkPositions();
            }
            
            onClick(event) {
                if (this._processingSelection) return;
                this._processingSelection = true;
                
                // Get mouse position
                const rect = this.container.getBoundingClientRect();
                this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                // Update raycaster
                this.raycaster.setFromCamera(this.mouse, this.camera);
                
                // Find intersected nodes
                const intersects = this.raycaster.intersectObjects(Array.from(this.nodes.values()));
                
                if (intersects.length > 0) {
                    const clickedNode = intersects[0].object;
                    const nodeData = clickedNode.userData.node;
                    const nodeId = nodeData.id;
                    
                    console.log(`Clicked on node: ${nodeId}, expandable: ${nodeData.expandable}, has_children: ${nodeData.has_children}, level: ${nodeData.level}`);
                    
                    // Fetch the node details and display them
                    this.selectNode(nodeData);
                    
                    // Toggle node expansion on click for expandable nodes
                    if (nodeData.expandable || nodeData.has_children) {
                        console.log(`Node ${nodeId} is expandable, toggling expansion...`);
                        this.toggleNodeExpansion(nodeId);
                    } else {
                        console.log(`Node ${nodeId} is not expandable`);
                    }
                } else {
                    // Deselect if clicking on empty space
                    this.deselectNode();
                }
                
                setTimeout(() => {
                    this._processingSelection = false;
                }, 300);
            }
            
            selectNode(nodeData) {
                // Deselect currently selected node if any
                if (this.selectedNode) {
                    const selectedMesh = this.nodes.get(this.selectedNode.id);
                    if (selectedMesh) {
                        selectedMesh.userData.isFixed = false;
                        
                        // Reset material
                        const nodeType = this.selectedNode.type;
                        const color = this.getNodeColor(nodeType);
                        const texture = this.createTextureForNode(this.selectedNode.name, color);
                        selectedMesh.material.map = texture;
                        selectedMesh.material.needsUpdate = true;
                    }
                }
                
                // Set new selected node
                this.selectedNode = nodeData;
                
                // Update appearance of selected node
                const nodeMesh = this.nodes.get(nodeData.id);
                if (nodeMesh) {
                    nodeMesh.userData.isFixed = true;
                    
                    // Highlight selected node
                    const color = this.getNodeColor(nodeData.type, true); // true for selected state
                    const texture = this.createTextureForNode(nodeData.name, color);
                    nodeMesh.material.map = texture;
                    nodeMesh.material.needsUpdate = true;
                    
                    // Move camera to focus on the selected node
                    this.focusOnNode(nodeMesh);
                }
                
                // Update details panel
                this.showNodeDetails(nodeData);
            }
            
            deselectNode() {
                if (this.selectedNode) {
                    const selectedMesh = this.nodes.get(this.selectedNode.id);
                    if (selectedMesh) {
                        selectedMesh.userData.isFixed = false;
                        
                        // Reset material
                        const nodeType = this.selectedNode.type;
                        const color = this.getNodeColor(nodeType);
                        const texture = this.createTextureForNode(this.selectedNode.name, color);
                        selectedMesh.material.map = texture;
                        selectedMesh.material.needsUpdate = true;
                    }
                    
                    this.selectedNode = null;
                    
                    // Clear details panel
                    document.getElementById('details-title').textContent = 'Select a node to view details';
                    document.getElementById('details-content').innerHTML = '';
                }
            }
            
            toggleNodeExpansion(nodeId) {
                if (this._processingExpansion) return;
                this._processingExpansion = true;
                
                console.log(`Toggling expansion for node: ${nodeId}`);
                
                const isExpanded = this.expandedNodes.has(nodeId);
                if (isExpanded) {
                    // Collapse this node
                    console.log(`Collapsing node: ${nodeId}`);
                    this.collapseNode(nodeId);
                } else {
                    // Expand this node
                    console.log(`Expanding node: ${nodeId}`);
                    this.expandNode(nodeId);
                }
            }
            
            expandNode(nodeId) {
                console.log(`Expanding node with ID: ${nodeId}`);
                
                // Mark as expanded
                this.expandedNodes.add(nodeId);
                
                // Get child links for this node
                const childLinks = this.graphData.links.filter(link => {
                    const source = typeof link.source === 'object' ? link.source.id : link.source;
                    return source === nodeId;
                });
                
                console.log(`Found ${childLinks.length} child links for node ${nodeId}`);
                
                if (childLinks.length === 0) {
                    console.log(`No child nodes found for ${nodeId}`);
                    this._processingExpansion = false;
                    return;
                }
                
                // Get child node IDs from the links
                const childNodeIds = childLinks.map(link => {
                    return typeof link.target === 'object' ? link.target.id : link.target;
                });
                console.log(`Child nodes for ${nodeId}: ${childNodeIds.join(', ')}`);
                
                // Update the visualization with all visible nodes
                const visibleNodes = this.getVisibleNodes();
                console.log(`Visible nodes: ${visibleNodes.length}`);
                const visibleLinks = this.getVisibleLinks(visibleNodes);
                console.log(`Visible links: ${visibleLinks.length}`);
                
                // Position all nodes
                this.positionNodes(visibleNodes);
                
                // Update visual elements
                this.createNodeObjects(visibleNodes);
                this.createLinkObjects(visibleLinks);
                this.setupNodeOrbits(visibleNodes);
                
                setTimeout(() => {
                    this._processingExpansion = false;
                }, 300);
            }
            
            collapseNode(nodeId) {
                if (this._processingExpansion) return;
                this._processingExpansion = true;
                
                // Remove this node from expanded nodes
                this.expandedNodes.delete(nodeId);
                
                // Also remove any child nodes from expanded nodes
                const childrenToCollapse = this.findAllChildren(nodeId);
                for (const childId of childrenToCollapse) {
                    this.expandedNodes.delete(childId);
                }
                
                // Update the visualization
                const visibleNodes = this.getVisibleNodes();
                const visibleLinks = this.getVisibleLinks(visibleNodes);
                
                // Position visible nodes
                this.positionNodes(visibleNodes);
                
                // Update visual elements
                this.createNodeObjects(visibleNodes);
                this.createLinkObjects(visibleLinks);
                this.setupNodeOrbits(visibleNodes);
                
                setTimeout(() => {
                    this._processingExpansion = false;
                }, 500);
            }
            
            findAllChildren(nodeId) {
                const children = [];
                
                // Find direct children
                const directChildren = this.graphData.nodes.filter(node => node.parent === nodeId);
                
                // Add direct children and recursively add their children
                for (const child of directChildren) {
                    children.push(child.id);
                    children.push(...this.findAllChildren(child.id));
                }
                
                return children;
            }
            
            showNodeDetails(nodeData) {
                // Update title
                document.getElementById('details-title').textContent = nodeData.name;
                
                // Clear previous content
                const detailsContent = document.getElementById('details-content');
                detailsContent.innerHTML = '';
                const referencesContent = document.getElementById('references-content');
                referencesContent.innerHTML = '';
                
                // Create breadcrumb navigation
                this.createBreadcrumbNavigation(nodeData);
                
                // First, create placeholder content to show while loading
                detailsContent.innerHTML = `
                    <div class="loading-indicator">
                        <p>Loading details for ${nodeData.name}...</p>
                    </div>
                `;
                
                // Fetch and display detailed node information
                fetch(`/api/details/${nodeData.id}`)
                    .then(response => response.json())
                    .then(data => {
                        // Clear loading indicator
                        detailsContent.innerHTML = '';
                        
                        console.log('Node details:', data);
                        
                        // Create core identity section (always shown)
                        const coreSection = document.createElement('div');
                        coreSection.className = 'detail-section core-identity';
                        
                        // Add node type badge
                        let nodeTypeHtml = `<div class="node-type-badge ${data.type}">${this.capitalizeFirstLetter(data.type)}</div>`;
                        
                        // Add description if available
                        let descriptionHtml = '';
                        if (data.description) {
                            descriptionHtml = `
                                <div class="detail-description">
                                    <p>${data.description}</p>
                                </div>
                            `;
                        }
                        
                        coreSection.innerHTML = `
                            <div class="section-header">
                                ${nodeTypeHtml}
                            </div>
                            ${descriptionHtml}
                        `;
                        
                        detailsContent.appendChild(coreSection);
                        
                        // Add all data as JSON if in development mode
                        if (location.hostname === 'localhost' || location.hostname === '127.0.0.1') {
                            const debugSection = document.createElement('div');
                            debugSection.className = 'detail-section debug-section';
                            debugSection.innerHTML = `
                                <div class="section-header">
                                    <h3>Debug Data</h3>
                                    <span class="section-toggle">▼</span>
                                </div>
                                <div class="section-content">
                                    <pre>${JSON.stringify(data, null, 2)}</pre>
                                </div>
                            `;
                            detailsContent.appendChild(debugSection);
                        }
                        
                        // Render type-specific details
                        switch(data.type) {
                            case 'component-group':
                                this.renderComponentGroupDetails(data, detailsContent);
                                break;
                            case 'component':
                                this.renderComponentDetails(data, detailsContent);
                                break;
                            case 'subcomponent':
                                this.renderSubcomponentDetails(data, detailsContent);
                                break;
                            case 'capability':
                                this.renderCapabilityDetails(data, detailsContent);
                                break;
                            case 'function':
                                this.renderFunctionDetails(data, detailsContent);
                                break;
                            case 'specification':
                                this.renderSpecificationDetails(data, detailsContent);
                                break;
                            case 'integration':
                                this.renderIntegrationDetails(data, detailsContent);
                                break;
                            case 'technique':
                                this.renderTechniqueDetails(data, detailsContent);
                                break;
                            case 'application':
                                this.renderApplicationDetails(data, detailsContent);
                                break;
                            case 'input':
                                this.renderInputDetails(data, detailsContent);
                                break;
                            case 'output':
                                this.renderOutputDetails(data, detailsContent);
                                break;
                            default:
                                // Generic rendering for other types
                                this.renderGenericDetails(data, detailsContent);
                        }
                        
                        // Show literature references if available
                        if (data.literature && data.literature.length > 0) {
                            data.literature.forEach(ref => {
                                const refEl = document.createElement('div');
                                refEl.className = 'reference-item';
                                
                                let authorText = ref.authors ? `<span class="ref-authors">${ref.authors}</span>` : '';
                                let yearText = ref.year ? `<span class="ref-year">(${ref.year})</span>` : '';
                                let titleText = ref.title ? `<span class="ref-title">${ref.title}</span>` : '';
                                let relevanceText = ref.relevance ? `<div class="ref-relevance">${ref.relevance}</div>` : '';
                                
                                refEl.innerHTML = `
                                    <div class="ref-header">
                                        ${authorText} ${yearText}
                                    </div>
                                    <div class="ref-body">
                                        ${titleText}
                                        ${relevanceText}
                                    </div>
                                `;
                                
                                referencesContent.appendChild(refEl);
                            });
                        } else {
                            // Try to extract literature references from other fields
                            let foundLiterature = false;
                            
                            // Check for literature_references field
                            if (data.literature_references && data.literature_references.length > 0) {
                                foundLiterature = true;
                                data.literature_references.forEach(ref => {
                                    const refEl = document.createElement('div');
                                    refEl.className = 'reference-item';
                                    
                                    // Handle different formats of literature references
                                    if (typeof ref === 'string') {
                                        refEl.innerHTML = `<div class="ref-body">${ref}</div>`;
                                    } else {
                                        let authorText = ref.authors ? `<span class="ref-authors">${ref.authors}</span>` : '';
                                        let yearText = ref.year ? `<span class="ref-year">(${ref.year})</span>` : '';
                                        let titleText = ref.title ? `<span class="ref-title">${ref.title}</span>` : '';
                                        
                                        refEl.innerHTML = `
                                            <div class="ref-header">
                                                ${authorText} ${yearText}
                                            </div>
                                            <div class="ref-body">
                                                ${titleText}
                                            </div>
                                        `;
                                    }
                                    
                                    referencesContent.appendChild(refEl);
                                });
                            }
                            
                            // Check for references field
                            if (data.references && data.references.length > 0) {
                                foundLiterature = true;
                                data.references.forEach(ref => {
                                    const refEl = document.createElement('div');
                                    refEl.className = 'reference-item';
                                    
                                    // Handle different formats of references
                                    if (typeof ref === 'string') {
                                        refEl.innerHTML = `<div class="ref-body">${ref}</div>`;
                                    } else {
                                        let authorText = ref.authors ? `<span class="ref-authors">${ref.authors}</span>` : '';
                                        let yearText = ref.year ? `<span class="ref-year">(${ref.year})</span>` : '';
                                        let titleText = ref.title ? `<span class="ref-title">${ref.title}</span>` : '';
                                        
                                        refEl.innerHTML = `
                                            <div class="ref-header">
                                                ${authorText} ${yearText}
                                            </div>
                                            <div class="ref-body">
                                                ${titleText}
                                            </div>
                                        `;
                                    }
                                    
                                    referencesContent.appendChild(refEl);
                                });
                            }
                            
                            if (!foundLiterature) {
                                referencesContent.innerHTML = '<div class="empty-section">No literature references available</div>';
                            }
                        }
                        
                        // Setup section toggles
                        this.setupSectionToggles();
                        
                        // Setup clickable items
                        this.setupClickableItems();
                    })
                    .catch(error => {
                        console.error("Error fetching node details:", error);
                        detailsContent.innerHTML = `
                            <div class="error-message">
                                <h3>Error Loading Details</h3>
                                <p>Could not load details for ${nodeData.name}</p>
                                <button onclick="location.reload()">Retry</button>
                            </div>
                        `;
                    });
            }
            
            capitalizeFirstLetter(string) {
                return string.charAt(0).toUpperCase() + string.slice(1);
            }
            
            createBreadcrumbNavigation(nodeData) {
                const breadcrumbContainer = document.getElementById('breadcrumb-navigation');
                breadcrumbContainer.innerHTML = '';
                
                // Fetch the hierarchy path for this node
                fetch(`/api/hierarchy-path/${nodeData.id}`)
                    .then(response => response.json())
                    .then(pathData => {
                        if (pathData && pathData.path && pathData.path.length > 0) {
                            pathData.path.forEach((item, index) => {
                                const breadcrumbItem = document.createElement('div');
                                breadcrumbItem.className = 'breadcrumb-item' + (index < pathData.path.length - 1 ? ' clickable' : '');
                                breadcrumbItem.innerHTML = item.name;
                                
                                // Add separator except for the last item
                                if (index < pathData.path.length - 1) {
                                    breadcrumbItem.innerHTML += ' <span class="breadcrumb-separator">›</span>';
                                    
                                    // Make parent items clickable
                                    breadcrumbItem.addEventListener('click', () => {
                                        // Find the node in the graph and navigate to it
                                        if (this.graph && typeof this.graph.graphData === 'function') {
                                            const graphData = this.graph.graphData();
                                            const node = graphData.nodes.find(n => n.id === item.id);
                                            if (node) {
                                                this.graph.centerAt(node.x, node.y, 1000);
                                                this.graph.zoom(1.5, 1000);
                                                setTimeout(() => this.showNodeDetails(node), 1000);
                                            }
                                        }
                                    });
                                }
                                
                                breadcrumbContainer.appendChild(breadcrumbItem);
                            });
                        }
                    });
            }
            
            renderComponentGroupDetails(data, container) {
                // Overview
                if (data.description || data.overview) {
                    const overviewSection = document.createElement('div');
                    overviewSection.className = 'detail-section';
                    
                    let overviewContent = data.overview || data.description || '';
                    
                    overviewSection.innerHTML = `
                        <div class="section-header">
                            <h3>Overview</h3>
                            <span class="section-toggle">▼</span>
                        </div>
                        <div class="section-content">
                            <p>${overviewContent}</p>
                        </div>
                    `;
                    
                    container.appendChild(overviewSection);
                }
                
                // Architectural Significance
                if (data.architectural_significance) {
                    const archSection = document.createElement('div');
                    archSection.className = 'detail-section';
                    
                    let archContent = typeof data.architectural_significance === 'string' ? 
                        data.architectural_significance : 
                        JSON.stringify(data.architectural_significance);
                    
                    archSection.innerHTML = `
                        <div class="section-header">
                            <h3>Architectural Significance</h3>
                            <span class="section-toggle">▼</span>
                        </div>
                        <div class="section-content">
                            <p>${archContent}</p>
                        </div>
                    `;
                    
                    container.appendChild(archSection);
                }
                
                // Purpose and Key Principles
                if (data.purpose || data.principles) {
                    const purposeSection = document.createElement('div');
                    purposeSection.className = 'detail-section';
                    
                    let purposeHtml = data.purpose ? `<p>${data.purpose}</p>` : '';
                    let principlesHtml = '';
                    
                    if (data.principles && data.principles.length > 0) {
                        principlesHtml = `
                            <h4>Key Principles</h4>
                            <ul class="principles-list">
                                ${data.principles.map(p => `<li>${p}</li>`).join('')}
                            </ul>
                        `;
                    }
                    
                    purposeSection.innerHTML = `
                        <div class="section-header">
                            <h3>Purpose & Principles</h3>
                            <span class="section-toggle">▼</span>
                        </div>
                        <div class="section-content">
                            ${purposeHtml}
                            ${principlesHtml}
                        </div>
                    `;
                    
                    container.appendChild(purposeSection);
                }
                
                // Overarching Goals
                if (data.goals && data.goals.length > 0) {
                    const goalsSection = document.createElement('div');
                    goalsSection.className = 'detail-section';
                    
                    let goalsHtml = `
                        <ul class="goals-list">
                            ${data.goals.map(g => `<li>${g}</li>`).join('')}
                        </ul>
                    `;
                    
                    goalsSection.innerHTML = `
                        <div class="section-header">
                            <h3>Overarching Goals</h3>
                            <span class="section-toggle">▼</span>
                        </div>
                        <div class="section-content">
                            ${goalsHtml}
                        </div>
                    `;
                    
                    container.appendChild(goalsSection);
                }
                
                // Key Challenges
                if (data.challenges && data.challenges.length > 0) {
                    const challengesSection = document.createElement('div');
                    challengesSection.className = 'detail-section';
                    
                    let challengesHtml = `
                        <ul class="challenges-list">
                            ${data.challenges.map(c => `
                                <li>
                                    <strong>${c.name || 'Challenge'}</strong>
                                    ${c.description ? `<p>${c.description}</p>` : ''}
                                </li>
                            `).join('')}
                        </ul>
                    `;
                    
                    challengesSection.innerHTML = `
                        <div class="section-header">
                            <h3>Key Challenges</h3>
                            <span class="section-toggle">▼</span>
                        </div>
                        <div class="section-content">
                            ${challengesHtml}
                        </div>
                    `;
                    
                    container.appendChild(challengesSection);
                }
                
                // Components
                if (data.components && data.components.length > 0) {
                    const componentsSection = document.createElement('div');
                    componentsSection.className = 'detail-section';
                    
                    let componentsContent = `
                        <ul class="components-list clickable-list">
                            ${data.components.map(c => `
                                <li data-id="${c.id}" class="clickable-item">
                                    <span class="node-type-badge component">Component</span>
                                    <strong>${c.name}</strong>
                                    ${c.description ? `<div class="item-description">${c.description}</div>` : ''}
                                    ${c.purpose ? `<div class="item-purpose"><em>Purpose:</em> ${c.purpose}</div>` : ''}
                                </li>
                            `).join('')}
                        </ul>
                    `;
                    
                    componentsSection.innerHTML = `
                        <div class="section-header">
                            <h3>Components</h3>
                            <span class="section-toggle">▼</span>
                        </div>
                        <div class="section-content">
                            ${componentsContent}
                        </div>
                    `;
                    
                    container.appendChild(componentsSection);
                    
                    // Add click handlers
                    componentsSection.querySelectorAll('.clickable-item').forEach(item => {
                        item.addEventListener('click', () => {
                            const nodeId = item.getAttribute('data-id');
                            if (nodeId) {
                                this.navigateToNode(nodeId);
                            }
                        });
                    });
                }
                
                // Research Areas
                if (data.research_areas && data.research_areas.length > 0) {
                    const researchSection = document.createElement('div');
                    researchSection.className = 'detail-section';
                    
                    let researchHtml = `
                        <ul class="research-list">
                            ${data.research_areas.map(r => `
                                <li>
                                    <strong>${r.name || 'Research Area'}</strong>
                                    ${r.description ? `<p>${r.description}</p>` : ''}
                                    ${r.key_questions && r.key_questions.length > 0 ? `
                                        <div class="key-questions">
                                            <h5>Key Questions:</h5>
                                            <ul>
                                                ${r.key_questions.map(q => `<li>${q}</li>`).join('')}
                                            </ul>
                                        </div>
                                    ` : ''}
                                </li>
                            `).join('')}
                        </ul>
                    `;
                    
                    researchSection.innerHTML = `
                        <div class="section-header">
                            <h3>Research Areas</h3>
                            <span class="section-toggle">▼</span>
                        </div>
                        <div class="section-content">
                            ${researchHtml}
                        </div>
                    `;
                    
                    container.appendChild(researchSection);
                }
            }
            
            renderComponentDetails(data, container) {
                // Purpose
                if (data.purpose) {
                    const purposeSection = document.createElement('div');
                    purposeSection.className = 'detail-section';
                    
                    purposeSection.innerHTML = `
                        <div class="section-header">
                            <h3>Purpose</h3>
                            <span class="section-toggle">▼</span>
                        </div>
                        <div class="section-content">
                            <p>${data.purpose}</p>
                        </div>
                    `;
                    
                    container.appendChild(purposeSection);
                }
                
                // Key Principles
                if (data.principles && data.principles.length > 0) {
                    const principlesSection = document.createElement('div');
                    principlesSection.className = 'detail-section';
                    
                    let principlesHtml = `
                        <ul class="principles-list">
                            ${data.principles.map(p => `<li>${p}</li>`).join('')}
                        </ul>
                    `;
                    
                    principlesSection.innerHTML = `
                        <div class="section-header">
                            <h3>Key Principles</h3>
                            <span class="section-toggle">▼</span>
                        </div>
                        <div class="section-content">
                            ${principlesHtml}
                        </div>
                    `;
                    
                    container.appendChild(principlesSection);
                }
                
                // Implementation Strategy
                if (data.implementation_strategy) {
                    const strategySection = document.createElement('div');
                    strategySection.className = 'detail-section';
                    
                    let strategyContent = data.implementation_strategy;
                    if (typeof strategyContent === 'object') {
                        strategyContent = `
                            <h4>${strategyContent.name || 'Strategy'}</h4>
                            <p>${strategyContent.description || ''}</p>
                            ${strategyContent.steps && strategyContent.steps.length > 0 ? `
                                <h5>Implementation Steps:</h5>
                                <ol>
                                    ${strategyContent.steps.map(step => `<li>${step}</li>`).join('')}
                                </ol>
                            ` : ''}
                        `;
                    }
                    
                    strategySection.innerHTML = `
                        <div class="section-header">
                            <h3>Implementation Strategy</h3>
                            <span class="section-toggle">▼</span>
                        </div>
                        <div class="section-content">
                            ${strategyContent}
                        </div>
                    `;
                    
                    container.appendChild(strategySection);
                }
                
                // Key Capabilities
                if (data.capabilities && data.capabilities.length > 0) {
                    const capsSection = document.createElement('div');
                    capsSection.className = 'detail-section';
                    
                    let capsContent = `
                        <ul class="capabilities-list clickable-list">
                            ${data.capabilities.map(c => `
                                <li data-id="${c.id}" class="clickable-item">
                                    <span class="node-type-badge capability">Capability</span>
                                    <strong>${c.name}</strong>
                                    ${c.description ? `<div class="item-description">${c.description}</div>` : ''}
                                </li>
                            `).join('')}
                        </ul>
                    `;
                    
                    capsSection.innerHTML = `
                        <div class="section-header">
                            <h3>Key Capabilities</h3>
                            <span class="section-toggle">▼</span>
                        </div>
                        <div class="section-content">
                            ${capsContent}
                        </div>
                    `;
                    
                    container.appendChild(capsSection);
                    
                    // Add click handlers
                    capsSection.querySelectorAll('.clickable-item').forEach(item => {
                        item.addEventListener('click', () => {
                            const nodeId = item.getAttribute('data-id');
                            if (nodeId) {
                                this.navigateToNode(nodeId);
                            }
                        });
                    });
                }
                
                // Key Functions
                if (data.functions && data.functions.length > 0) {
                    const funcsSection = document.createElement('div');
                    funcsSection.className = 'detail-section';
                    
                    let funcsContent = `
                        <ul class="functions-list clickable-list">
                            ${data.functions.map(f => `
                                <li data-id="${f.id}" class="clickable-item">
                                    <span class="node-type-badge function">Function</span>
                                    <strong>${f.name}</strong>
                                    ${f.description ? `<div class="item-description">${f.description}</div>` : ''}
                                </li>
                            `).join('')}
                        </ul>
                    `;
                    
                    funcsSection.innerHTML = `
                        <div class="section-header">
                            <h3>Key Functions</h3>
                            <span class="section-toggle">▼</span>
                        </div>
                        <div class="section-content">
                            ${funcsContent}
                        </div>
                    `;
                    
                    container.appendChild(funcsSection);
                    
                    // Add click handlers
                    funcsSection.querySelectorAll('.clickable-item').forEach(item => {
                        item.addEventListener('click', () => {
                            const nodeId = item.getAttribute('data-id');
                            if (nodeId) {
                                this.navigateToNode(nodeId);
                            }
                        });
                    });
                }
                
                // Success Criteria
                if (data.success_criteria && data.success_criteria.length > 0) {
                    const criteriaSection = document.createElement('div');
                    criteriaSection.className = 'detail-section';
                    
                    let criteriaContent = `
                        <ul class="criteria-list">
                            ${data.success_criteria.map(c => `
                                <li>
                                    <strong>${c.name || 'Criteria'}</strong>
                                    ${c.description ? `<p>${c.description}</p>` : ''}
                                    ${c.metrics && c.metrics.length > 0 ? `
                                        <div class="metrics">
                                            <h5>Metrics:</h5>
                                            <ul>
                                                ${c.metrics.map(m => `<li>${m}</li>`).join('')}
                                            </ul>
                                        </div>
                                    ` : ''}
                                </li>
                            `).join('')}
                        </ul>
                    `;
                    
                    criteriaSection.innerHTML = `
                        <div class="section-header">
                            <h3>Success Criteria</h3>
                            <span class="section-toggle">▼</span>
                        </div>
                        <div class="section-content">
                            ${criteriaContent}
                        </div>
                    `;
                    
                    container.appendChild(criteriaSection);
                }
                
                // Subcomponents
                if (data.subcomponents && data.subcomponents.length > 0) {
                    const subcompsSection = document.createElement('div');
                    subcompsSection.className = 'detail-section';
                    
                    let subcompsContent = `
                        <ul class="subcomponents-list clickable-list">
                            ${data.subcomponents.map(s => `
                                <li data-id="${s.id}" class="clickable-item">
                                    <span class="node-type-badge subcomponent">Subcomponent</span>
                                    <strong>${s.name}</strong>
                                    ${s.description ? `<div class="item-description">${s.description}</div>` : ''}
                                </li>
                            `).join('')}
                        </ul>
                    `;
                    
                    subcompsSection.innerHTML = `
                        <div class="section-header">
                            <h3>Subcomponents</h3>
                            <span class="section-toggle">▼</span>
                        </div>
                        <div class="section-content">
                            ${subcompsContent}
                        </div>
                    `;
                    
                    container.appendChild(subcompsSection);
                    
                    // Add click handlers
                    subcompsSection.querySelectorAll('.clickable-item').forEach(item => {
                        item.addEventListener('click', () => {
                            const nodeId = item.getAttribute('data-id');
                            if (nodeId) {
                                this.navigateToNode(nodeId);
                            }
                        });
                    });
                }
                
                // Challenges & Limitations
                if (data.challenges_and_limitations && data.challenges_and_limitations.length > 0) {
                    const challengesSection = document.createElement('div');
                    challengesSection.className = 'detail-section';
                    
                    let challengesContent = `
                        <ul class="challenges-list">
                            ${data.challenges_and_limitations.map(c => `
                                <li>
                                    <strong>${c.name || 'Challenge'}</strong>
                                    ${c.description ? `<p>${c.description}</p>` : ''}
                                    ${c.mitigation_strategies && c.mitigation_strategies.length > 0 ? `
                                        <div class="mitigation">
                                            <h5>Mitigation Strategies:</h5>
                                            <ul>
                                                ${c.mitigation_strategies.map(m => `<li>${m}</li>`).join('')}
                                            </ul>
                                        </div>
                                    ` : ''}
                                </li>
                            `).join('')}
                        </ul>
                    `;
                    
                    challengesSection.innerHTML = `
                        <div class="section-header">
                            <h3>Challenges & Limitations</h3>
                            <span class="section-toggle">▼</span>
                        </div>
                        <div class="section-content">
                            ${challengesContent}
                        </div>
                    `;
                    
                    container.appendChild(challengesSection);
                }
                
                // Cross Connections
                if (data.cross_connections && data.cross_connections.length > 0) {
                    const crossSection = document.createElement('div');
                    crossSection.className = 'detail-section';
                    
                    let crossContent = `
                        <ul class="cross-connections-list clickable-list">
                            ${data.cross_connections.map(c => `
                                <li data-id="${c.id}" class="clickable-item">
                                    <span class="node-type-badge ${c.type}">${this.capitalizeFirstLetter(c.type)}</span>
                                    <strong>${c.name}</strong>
                                    ${c.description ? `<div class="item-description">${c.description}</div>` : ''}
                                    ${c.relationship ? `<div class="relationship-description"><em>Relationship:</em> ${c.relationship}</div>` : ''}
                                </li>
                            `).join('')}
                        </ul>
                    `;
                    
                    crossSection.innerHTML = `
                        <div class="section-header">
                            <h3>Cross Connections</h3>
                            <span class="section-toggle">▼</span>
                        </div>
                        <div class="section-content">
                            ${crossContent}
                        </div>
                    `;
                    
                    container.appendChild(crossSection);
                    
                    // Add click handlers
                    crossSection.querySelectorAll('.clickable-item').forEach(item => {
                        item.addEventListener('click', () => {
                            const nodeId = item.getAttribute('data-id');
                            if (nodeId) {
                                this.navigateToNode(nodeId);
                            }
                        });
                    });
                }
            }
            
            renderCapabilityDetails(data, container) {
                // Handle functions in different formats
                let functions = [];
                if (data.functions) {
                    if (Array.isArray(data.functions)) {
                        functions = data.functions;
                    } else if (data.functions.items && Array.isArray(data.functions.items)) {
                        functions = data.functions.items;
                    }
                }
                
                // Component capabilities implementations
                if (data.implements_component_capabilities && data.implements_component_capabilities.length > 0) {
                    const implEl = document.createElement('div');
                    implEl.className = 'detail-section';
                    implEl.innerHTML = `
                        <h3>Implements Component Capabilities <span class="section-toggle">-</span></h3>
                        <div class="section-content">
                            <div class="relationship-container">
                                ${data.implements_component_capabilities.map(impl => `
                                    <div class="info-box">
                                        <div class="info-box-title">
                                            <span class="clickable-item" data-node-id="${impl}">${this.getFriendlyName(impl)}</span>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                    container.appendChild(implEl);
                }
                
                if (functions.length > 0) {
                    const funcsEl = document.createElement('div');
                    funcsEl.className = 'detail-section';
                    funcsEl.innerHTML = `
                        <h3>Functions <span class="section-toggle">-</span></h3>
                        <div class="section-content">
                            ${functions.map(func => `
                                <div class="info-box">
                                    <div class="info-box-title">
                                        <span class="clickable-item" data-node-id="${this.formatNodeId(data.id, 'function', func)}">${func.name || (typeof func === 'string' ? func : 'Function')}</span>
                                    </div>
                                    <div class="info-box-content">
                                        ${func.description || ''}
                                        ${func.implements_component_functions && func.implements_component_functions.length > 0 ? `
                                            <div class="expandable-section">
                                                <div class="relationship-type">Implements:</div>
                                                <div class="relationship-container">
                                                    ${func.implements_component_functions.map(impl => `
                                                        <span class="clickable-item" data-node-id="${impl}">${this.getFriendlyName(impl)}</span>
                                                    `).join('')}
                                                </div>
                                            </div>
                                        ` : ''}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    `;
                    container.appendChild(funcsEl);
                }
                
                // Show supported literature if available
                if (data.supported_by_literature && data.supported_by_literature.length > 0) {
                    const litEl = document.createElement('div');
                    litEl.className = 'detail-section';
                    litEl.innerHTML = `
                        <h3>Supported by Literature <span class="section-toggle">-</span></h3>
                        <div class="section-content">
                            <ul>
                                ${data.supported_by_literature.map(ref => `
                                    <li><span class="clickable-item literature-ref" data-ref-id="${ref}">${ref}</span></li>
                                `).join('')}
                            </ul>
                        </div>
                    `;
                    container.appendChild(litEl);
                }
            }
            
            renderFunctionDetails(data, container) {
                // Component functions implementations
                if (data.implements_component_functions && data.implements_component_functions.length > 0) {
                    const implEl = document.createElement('div');
                    implEl.className = 'detail-section';
                    implEl.innerHTML = `
                        <h3>Implements Component Functions <span class="section-toggle">-</span></h3>
                        <div class="section-content">
                            <div class="relationship-container">
                                ${data.implements_component_functions.map(impl => `
                                    <div class="info-box">
                                        <div class="info-box-title">
                                            <span class="clickable-item" data-node-id="${impl}">${this.getFriendlyName(impl)}</span>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                    container.appendChild(implEl);
                }
                
                // Handle specifications
                let specifications = [];
                if (data.specifications) {
                    if (Array.isArray(data.specifications)) {
                        specifications = data.specifications;
                    } else if (typeof data.specifications === 'object') {
                        specifications = [data.specifications];
                    }
                }
                
                if (specifications.length > 0) {
                    const specsEl = document.createElement('div');
                    specsEl.className = 'detail-section';
                    specsEl.innerHTML = `
                        <h3>Specifications <span class="section-toggle">-</span></h3>
                        <div class="section-content">
                            ${specifications.map(spec => `
                                <div class="info-box">
                                    <div class="info-box-title">
                                        <span class="clickable-item" data-node-id="${this.formatNodeId(data.id, 'spec', spec)}">${spec.name || 'Specification'}</span>
                                    </div>
                                    <div class="info-box-content">${spec.description || ''}</div>
                                </div>
                            `).join('')}
                        </div>
                    `;
                    container.appendChild(specsEl);
                }
                
                // Show supported literature if available
                if (data.supported_by_literature && data.supported_by_literature.length > 0) {
                    const litEl = document.createElement('div');
                    litEl.className = 'detail-section';
                    litEl.innerHTML = `
                        <h3>Supported by Literature <span class="section-toggle">-</span></h3>
                        <div class="section-content">
                            <ul>
                                ${data.supported_by_literature.map(ref => `
                                    <li><span class="clickable-item literature-ref" data-ref-id="${ref}">${ref}</span></li>
                                `).join('')}
                            </ul>
                        </div>
                    `;
                    container.appendChild(litEl);
                }
            }
            
            renderSpecificationDetails(data, container) {
                // Show requirements if available
                if (data.requirements && Array.isArray(data.requirements)) {
                    const reqsEl = document.createElement('div');
                    reqsEl.className = 'detail-section';
                    reqsEl.innerHTML = `
                        <h3>Requirements <span class="section-toggle">-</span></h3>
                        <div class="section-content">
                            <ul>
                                ${data.requirements.map(req => `<li>${req}</li>`).join('')}
                            </ul>
                        </div>
                    `;
                    container.appendChild(reqsEl);
                }
                
                // Show integration info
                if (data.integration) {
                    const intEl = document.createElement('div');
                    intEl.className = 'detail-section';
                    intEl.innerHTML = `
                        <h3>Integration <span class="section-toggle">-</span></h3>
                        <div class="section-content">
                            <div class="info-box">
                                <div class="info-box-title">
                                    <span class="clickable-item" data-node-id="${this.formatNodeId(data.id, 'integration', data.integration)}">${data.integration.name || 'Implementation'}</span>
                                </div>
                                <div class="info-box-content">${data.integration.description || ''}</div>
                            </div>
                        </div>
                    `;
                    container.appendChild(intEl);
                }
            }
            
            renderIntegrationDetails(data, container) {
                // Show techniques if available
                if (data.techniques && Array.isArray(data.techniques)) {
                    const techsEl = document.createElement('div');
                    techsEl.className = 'detail-section';
                    techsEl.innerHTML = `
                        <h3>Techniques <span class="section-toggle">-</span></h3>
                        <div class="section-content">
                            ${data.techniques.map(tech => `
                                <div class="info-box">
                                    <div class="info-box-title">
                                        <span class="clickable-item" data-node-id="${this.formatNodeId(data.id, 'technique', tech)}">${tech.name || 'Technique'}</span>
                                    </div>
                                    <div class="info-box-content">${tech.description || ''}</div>
                                </div>
                            `).join('')}
                        </div>
                    `;
                    container.appendChild(techsEl);
                }
            }
            
            renderTechniqueDetails(data, container) {
                // Show applications if available
                if (data.applications && Array.isArray(data.applications)) {
                    const appsEl = document.createElement('div');
                    appsEl.className = 'detail-section';
                    appsEl.innerHTML = `
                        <h3>Applications <span class="section-toggle">-</span></h3>
                        <div class="section-content">
                            ${data.applications.map(app => `
                                <div class="info-box">
                                    <div class="info-box-title">
                                        <span class="clickable-item" data-node-id="${this.formatNodeId(data.id, 'app', app)}">${app.name || 'Application'}</span>
                                    </div>
                                    <div class="info-box-content">${app.description || ''}</div>
                                </div>
                            `).join('')}
                        </div>
                    `;
                    container.appendChild(appsEl);
                }
            }
            
            renderApplicationDetails(data, container) {
                // Create a section for inputs and outputs
                const ioSection = document.createElement('div');
                ioSection.className = 'detail-section';
                let ioHTML = '';
                
                // Show inputs if available
                if (data.inputs && Array.isArray(data.inputs) && data.inputs.length > 0) {
                    ioHTML += `
                        <h3>Inputs <span class="section-toggle">-</span></h3>
                        <div class="section-content">
                            ${data.inputs.map(input => `
                                <div class="info-box">
                                    <div class="info-box-title">
                                        <span class="clickable-item" data-node-id="${this.formatNodeId(data.id, 'input', input)}">${input.name || 'Input'}</span>
                                    </div>
                                    <div class="info-box-content">
                                        ${input.description || ''}
                                        ${input.data_type ? `<br><strong>Type:</strong> ${input.data_type}` : ''}
                                        ${input.constraints ? `<br><strong>Constraints:</strong> ${input.constraints}` : ''}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    `;
                }
                
                // Show outputs if available
                if (data.outputs && Array.isArray(data.outputs) && data.outputs.length > 0) {
                    ioHTML += `
                        <h3>Outputs <span class="section-toggle">-</span></h3>
                        <div class="section-content">
                            ${data.outputs.map(output => `
                                <div class="info-box">
                                    <div class="info-box-title">
                                        <span class="clickable-item" data-node-id="${this.formatNodeId(data.id, 'output', output)}">${output.name || 'Output'}</span>
                                    </div>
                                    <div class="info-box-content">
                                        ${output.description || ''}
                                        ${output.data_type ? `<br><strong>Type:</strong> ${output.data_type}` : ''}
                                        ${output.interpretation ? `<br><strong>Interpretation:</strong> ${output.interpretation}` : ''}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    `;
                }
                
                if (ioHTML) {
                    ioSection.innerHTML = ioHTML;
                    container.appendChild(ioSection);
                }
            }
            
            renderIODetails(data, container, nodeType) {
                // Show data type and constraints
                if (data.data_type || data.constraints || data.interpretation) {
                    const detailsEl = document.createElement('div');
                    detailsEl.className = 'detail-section';
                    
                    let html = `<h3>Technical Details <span class="section-toggle">-</span></h3>
                    <div class="section-content">`;
                    
                    if (data.data_type) {
                        html += `
                            <div class="info-box">
                                <div class="info-box-title">Data Type</div>
                                <div class="info-box-content">${data.data_type}</div>
                            </div>
                        `;
                    }
                    
                    if (data.constraints) {
                        html += `
                            <div class="info-box">
                                <div class="info-box-title">Constraints</div>
                                <div class="info-box-content">${data.constraints}</div>
                            </div>
                        `;
                    }
                    
                    if (data.interpretation) {
                        html += `
                            <div class="info-box">
                                <div class="info-box-title">Interpretation</div>
                                <div class="info-box-content">${data.interpretation}</div>
                            </div>
                        `;
                    }
                    
                    html += `</div>`;
                    detailsEl.innerHTML = html;
                    container.appendChild(detailsEl);
                }
            }
            
            renderGenericDetails(data, container) {
                // Generic rendering for any node type that doesn't have a specific renderer
                // Display any key-value pairs that might be relevant to users
                
                const keys = Object.keys(data).filter(key => 
                    // Filter out system keys and already displayed information
                    !['id', 'name', 'type', 'description', 'literature'].includes(key) && 
                    // Filter out empty values
                    data[key] !== null && 
                    data[key] !== undefined && 
                    (typeof data[key] !== 'string' || data[key].trim() !== '') &&
                    (Array.isArray(data[key]) ? data[key].length > 0 : true)
                );
                
                if (keys.length > 0) {
                    const detailsEl = document.createElement('div');
                    detailsEl.className = 'detail-section';
                    
                    let html = `<h3>Additional Details <span class="section-toggle">-</span></h3>
                    <div class="section-content">`;
                    
                    keys.forEach(key => {
                        const value = data[key];
                        const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                        
                        if (Array.isArray(value)) {
                            // Handle array values
                            if (value.length > 0) {
                                html += `
                                    <div class="info-box">
                                        <div class="info-box-title">${displayKey}</div>
                                        <div class="info-box-content">
                                            <ul>
                                                ${value.map(item => {
                                                    if (typeof item === 'object') {
                                                        // Handle objects within arrays
                                                        if (item.name) {
                                                            return `<li><strong>${item.name}</strong>${item.description ? `: ${item.description}` : ''}</li>`;
                                                        } else {
                                                            return `<li>${JSON.stringify(item)}</li>`;
                                                        }
                                                    } else {
                                                        return `<li>${item}</li>`;
                                                    }
                                                }).join('')}
                                            </ul>
                                        </div>
                                    </div>
                                `;
                            }
                        } else if (typeof value === 'object' && value !== null) {
                            // Handle object values
                            html += `
                                <div class="info-box">
                                    <div class="info-box-title">${displayKey}</div>
                                    <div class="info-box-content">
                                        ${value.name ? `<strong>${value.name}</strong><br>` : ''}
                                        ${value.description ? value.description : JSON.stringify(value)}
                                    </div>
                                </div>
                            `;
                        } else {
                            // Handle primitive values
                            html += `
                                <div class="info-box">
                                    <div class="info-box-title">${displayKey}</div>
                                    <div class="info-box-content">${value}</div>
                                </div>
                            `;
                        }
                    });
                    
                    html += `</div>`;
                    detailsEl.innerHTML = html;
                    container.appendChild(detailsEl);
                }
            }
            
            renderInputDetails(data, container) {
                // Use the common IO details renderer with 'input' type
                this.renderIODetails(data, container, 'input');
            }
            
            renderOutputDetails(data, container) {
                // Use the common IO details renderer with 'output' type
                this.renderIODetails(data, container, 'output');
            }
            
            setupExpandableSections() {
                document.querySelectorAll('.section-toggle').forEach(toggle => {
                    if (!toggle.getAttribute('data-event-bound')) {
                        toggle.addEventListener('click', event => {
                            const section = event.target.closest('.detail-section');
                            const content = section.querySelector('.section-content');
                            
                            if (content.style.display === 'none') {
                                content.style.display = 'block';
                                event.target.textContent = '-';
                            } else {
                                content.style.display = 'none';
                                event.target.textContent = '+';
                            }
                        });
                        toggle.setAttribute('data-event-bound', 'true');
                    }
                });
            }
            
            renderLiteratureReferences(data) {
                const referencesContent = document.getElementById('references-content');
                referencesContent.innerHTML = '';
                
                // Check for literature connections
                if (data.literature_connections && data.literature_connections.length > 0) {
                    data.literature_connections.forEach(connection => {
                        const refEl = document.createElement('div');
                        refEl.className = 'reference-item';
                        refEl.innerHTML = `
                            <div class="reference-title">${connection.reference_id}</div>
                            ${connection.function ? `<div><strong>Function:</strong> ${this.getFriendlyName(connection.function)}</div>` : ''}
                            ${connection.capability ? `<div><strong>Capability:</strong> ${this.getFriendlyName(connection.capability)}</div>` : ''}
                            ${connection.technique ? `<div><strong>Technique:</strong> ${this.getFriendlyName(connection.technique)}</div>` : ''}
                            <div class="reference-details">${connection.relevant_aspects || ''}</div>
                        `;
                        referencesContent.appendChild(refEl);
                    });
                } else if (data.literature && data.literature.references) {
                    // If it has literature references but no connections
                    let refList = Array.isArray(data.literature.references) ? 
                                 data.literature.references : 
                                 [data.literature.references];
                    
                    refList.forEach(ref => {
                        const refEl = document.createElement('div');
                        refEl.className = 'reference-item';
                        let refDisplay = typeof ref === 'string' ? ref : ref.id || ref.title || 'Reference';
                        refEl.textContent = refDisplay;
                        referencesContent.appendChild(refEl);
                    });
                } else {
                    // No literature references
                    referencesContent.innerHTML = '<p>No literature references available</p>';
                }
            }
            
            setupClickableItems() {
                document.querySelectorAll('.clickable-item').forEach(item => {
                    if (item.getAttribute('data-event-bound') !== 'true') {
                        item.addEventListener('click', event => {
                            const nodeId = event.target.getAttribute('data-node-id');
                            if (nodeId) {
                                // Find the node in the graph and select it
                                const node = this.nodes.get(nodeId);
                                if (node) {
                                    // Programmatically trigger node selection
                                    const nodeData = node.userData.node;
                                    this.selectNode(nodeData);
                                    
                                    // Focus camera on this node
                                    this.focusOnNode(node);
                                }
                            }
                            
                            const refId = event.target.getAttribute('data-ref-id');
                            if (refId) {
                                // Handle literature reference click
                                // TODO: Show detailed literature info if available
                                console.log('Literature reference clicked:', refId);
                            }
                        });
                        item.setAttribute('data-event-bound', 'true');
                    }
                });
            }
            
            formatNodeId(parentId, type, item) {
                if (item.id) {
                    return item.id;
                }
                
                // Create a sanitized ID based on the item name
                const name = item.name || 'item';
                const sanitizedName = name.toLowerCase().replace(/[^a-z0-9]/g, '-');
                return `${parentId}-${type}-${sanitizedName}`;
            }
            
            getFriendlyName(id) {
                // Extract a friendly name from an ID like "technical-safeguards.containment-capability"
                if (!id) return 'Unknown';
                
                // Check if we have this node in our cached details
                const nodeDetails = this.nodeDetails.get(id);
                if (nodeDetails && nodeDetails.name) {
                    return nodeDetails.name;
                }
                
                // Otherwise try to extract a nicer name from the ID itself
                const parts = id.split('.');
                const lastPart = parts[parts.length - 1];
                
                // Convert kebab-case to Title Case
                return lastPart
                    .split('-')
                    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                    .join(' ');
            }
            
            onMouseMove(event) {
                // Calculate mouse position
                const rect = this.container.getBoundingClientRect();
                this.mouse.x = ((event.clientX - rect.left) / this.container.clientWidth) * 2 - 1;
                this.mouse.y = -((event.clientY - rect.top) / this.container.clientHeight) * 2 + 1;
            }
            
            onWindowResize() {
                const width = this.container.clientWidth;
                const height = this.container.clientHeight;
                
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(width, height);
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Update controls
                this.controls.update();
                
                // Apply global rotation if enabled
                if (this.isRotating) {
                    this.scene.rotation.y += 0.001;
                }
                
                // Update orbital animations - throttle updates to improve performance
                if (!this._lastOrbitUpdate || Date.now() - this._lastOrbitUpdate > 16) {  // ~60fps
                    this.updateNodePositions();
                    this._lastOrbitUpdate = Date.now();
                }
                
                // Render scene
                this.renderer.render(this.scene, this.camera);
                
                // Update TWEEN animations
                TWEEN.update();
            }
            
            // UI Controls
            zoomIn() {
                const targetPosition = this.camera.position.clone();
                targetPosition.multiplyScalar(0.8);
                
                new TWEEN.Tween(this.camera.position)
                    .to(targetPosition, 300)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();
            }
            
            zoomOut() {
                const targetPosition = this.camera.position.clone();
                targetPosition.multiplyScalar(1.2);
                
                new TWEEN.Tween(this.camera.position)
                    .to(targetPosition, 300)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();
            }
            
            resetView() {
                new TWEEN.Tween(this.camera.position)
                    .to({ x: 0, y: 0, z: 800 }, 500)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();
                    
                new TWEEN.Tween(this.scene.rotation)
                    .to({ x: 0, y: 0, z: 0 }, 500)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();
                    
                this.controls.reset();
            }
            
            toggleRotation() {
                this.isRotating = !this.isRotating;
            }
            
            // Helper methods
            setupDragControls() {
                // Create drag controls for node objects
                const nodeObjects = Array.from(this.nodes.values());
                this.dragControls = new DragControls(nodeObjects, this.camera, this.renderer.domElement);
                
                // Add event listeners
                this.dragControls.addEventListener('dragstart', (event) => {
                    this.controls.enabled = false;
                    this.isDragging = true;
                    
                    // Highlight the node being dragged
                    event.object.userData.isFixed = true; // Mark as fixed while dragging
                    
                    // Remove from orbital system while dragging
                    const nodeId = event.object.userData.node.id;
                    if (this.nodeOrbits.has(nodeId)) {
                        // Store current position as the orbit's new initial position
                        const orbit = this.nodeOrbits.get(nodeId);
                        orbit.initialPosition = event.object.position.clone().sub(orbit.center);
                    }
                });
                
                this.dragControls.addEventListener('drag', (event) => {
                    // Store the new position
                    const nodeId = event.object.userData.node.id;
                    this.nodePositions.set(nodeId, {
                        x: event.object.position.x,
                        y: event.object.position.y,
                        z: event.object.position.z
                    });
                    
                    // Update text label position
                    const textLabel = this.textLabels.get(nodeId);
                    if (textLabel) {
                        const nodeSize = this.getNodeSize(event.object.userData.node.type);
                        textLabel.position.copy(event.object.position);
                        textLabel.position.y += nodeSize + 20; // More space between node and label
                    }
                    
                    // Update links
                    this.updateLinkPositions();
                });
                
                this.dragControls.addEventListener('dragend', (event) => {
                    this.controls.enabled = true;
                    
                    // Allow a small delay before turning off isDragging flag to prevent accidental click
                    setTimeout(() => {
                        this.isDragging = false;
                    }, 100);
                    
                    // If node was specifically selected, keep it fixed
                    // Otherwise, allow it to resume orbiting
                    if (this.selectedNode !== event.object.userData.node) {
                        event.object.userData.isFixed = false;
                    }
                });
            }
            
            updateNodeLabels() {
                // Implementation of updateNodeLabels method
            }
            
            focusOnNode(nodeMesh) {
                if (!nodeMesh) return;
                
                // Calculate target position to center on the node
                const targetPosition = nodeMesh.position.clone();
                
                // Calculate the distance based on node size for proper zoom level
                const nodeSize = this.getNodeSize(nodeMesh.userData.node.type);
                const distance = nodeSize * 8; // Further distance for better viewing
                
                // Get current camera direction normalized
                const direction = new THREE.Vector3().subVectors(
                    this.camera.position, 
                    this.controls.target
                ).normalize();
                
                // Set new camera position at appropriate distance from node
                const newPosition = new THREE.Vector3().addVectors(
                    targetPosition,
                    direction.multiplyScalar(distance)
                );
                
                // Animate camera movement
                new TWEEN.Tween(this.camera.position)
                    .to(newPosition, 1000)
                    .easing(TWEEN.Easing.Cubic.Out)
                    .start();
                
                // Animate controls target
                new TWEEN.Tween(this.controls.target)
                    .to(targetPosition, 1000)
                    .easing(TWEEN.Easing.Cubic.Out)
                    .onUpdate(() => this.controls.update())
                    .start();
            }
            
            navigateToNode(nodeId) {
                console.log(`Navigating to node: ${nodeId}`);
                
                // Directly use the node from our stored nodes
                const node = this.nodes.get(nodeId);
                if (node) {
                    const nodeData = node.userData.node;
                    
                    // Ensure the path to the node is expanded
                    this.ensurePathIsExpanded(nodeData);
                    
                    // Center camera on the node
                    this.focusOnNode(node);
                    
                    // Select the node
                    this.selectNode(nodeData);
                    
                    // If the node is expandable, expand it automatically
                    if (nodeData.expandable && nodeData.has_children && !this.expandedNodes.has(nodeId)) {
                        setTimeout(() => {
                            this.expandNode(nodeId);
                        }, 500);
                    }
                } else {
                    console.warn(`Node with ID ${nodeId} not found in the graph. Checking node details...`);
                    
                    // Try to find it in nodeDetails if it's not in the visual graph yet
                    const nodeDetails = this.nodeDetails.get(nodeId);
                    if (nodeDetails) {
                        console.log(`Found node in details: ${nodeDetails.name}`);
                        
                        // Ensure path is expanded
                        this.ensurePathIsExpanded(nodeDetails);
                        
                        // Get updated visible nodes after expansion
                        const visibleNodes = this.getVisibleNodes();
                        const visibleLinks = this.getVisibleLinks(visibleNodes);
                        
                        // Update graph
                        this.positionNodes(visibleNodes);
                        this.createNodeObjects(visibleNodes);
                        this.createLinkObjects(visibleLinks);
                        this.setupNodeOrbits(visibleNodes);
                        
                        // Try again after refreshing the graph
                        setTimeout(() => {
                            const node = this.nodes.get(nodeId);
                            if (node) {
                                this.focusOnNode(node);
                                this.selectNode(node.userData.node);
                            } else {
                                console.error(`Failed to locate node ${nodeId} even after expansion.`);
                            }
                        }, 500);
                    } else {
                        console.error(`Node with ID ${nodeId} not found in node details either.`);
                    }
                }
            }
            
            ensurePathIsExpanded(nodeData) {
                if (nodeData.parent) {
                    // Ensure parent is expanded
                    this.expandedNodes.add(nodeData.parent);
                    
                    // Recursively ensure all ancestors are expanded
                    const parentNode = this.nodeDetails.get(nodeData.parent);
                    if (parentNode) {
                        this.ensurePathIsExpanded(parentNode);
                    }
                }
                
                // Refresh the visualization
                const visibleNodes = this.getVisibleNodes();
                const visibleLinks = this.getVisibleLinks(visibleNodes);
                this.positionNodes(visibleNodes);
                this.createNodeObjects(visibleNodes);
                this.createLinkObjects(visibleLinks);
                this.setupNodeOrbits(visibleNodes);
            }
            
            renderSubcomponentDetails(data, container) {
                // Parent Component
                if (data.parent_component) {
                    const parentSection = document.createElement('div');
                    parentSection.className = 'detail-section';
                    
                    parentSection.innerHTML = `
                        <div class="section-header">
                            <h3>Parent Component</h3>
                            <span class="section-toggle">▼</span>
                        </div>
                        <div class="section-content">
                            <div class="parent-component clickable-item" data-id="${data.parent_component.id}">
                                <span class="node-type-badge component">Component</span>
                                <strong>${data.parent_component.name}</strong>
                                ${data.parent_component.description ? `<div class="item-description">${data.parent_component.description}</div>` : ''}
                            </div>
                        </div>
                    `;
                    
                    container.appendChild(parentSection);
                    
                    // Add click handler for parent component
                    parentSection.querySelector('.clickable-item').addEventListener('click', () => {
                        const nodeId = data.parent_component.id;
                        this.navigateToNode(nodeId);
                    });
                }
                
                // Purpose 
                if (data.purpose) {
                    const purposeSection = document.createElement('div');
                    purposeSection.className = 'detail-section';
                    
                    purposeSection.innerHTML = `
                        <div class="section-header">
                            <h3>Purpose</h3>
                            <span class="section-toggle">▼</span>
                        </div>
                        <div class="section-content">
                            <p>${data.purpose}</p>
                        </div>
                    `;
                    
                    container.appendChild(purposeSection);
                }
                
                // Design Principles
                if (data.design_principles && data.design_principles.length > 0) {
                    const principlesSection = document.createElement('div');
                    principlesSection.className = 'detail-section';
                    
                    let principlesHtml = `
                        <ul class="design-principles-list">
                            ${data.design_principles.map(p => `
                                <li>
                                    <strong>${p.name || 'Principle'}</strong>
                                    ${p.description ? `<p>${p.description}</p>` : ''}
                                </li>
                            `).join('')}
                        </ul>
                    `;
                    
                    principlesSection.innerHTML = `
                        <div class="section-header">
                            <h3>Design Principles</h3>
                            <span class="section-toggle">▼</span>
                        </div>
                        <div class="section-content">
                            ${principlesHtml}
                        </div>
                    `;
                    
                    container.appendChild(principlesSection);
                }
                
                // Capabilities
                if (data.capabilities && data.capabilities.length > 0) {
                    const capsSection = document.createElement('div');
                    capsSection.className = 'detail-section';
                    
                    let capsContent = `
                        <ul class="capabilities-list clickable-list">
                            ${data.capabilities.map(c => `
                                <li data-id="${c.id}" class="clickable-item">
                                    <span class="node-type-badge capability">Capability</span>
                                    <strong>${c.name}</strong>
                                    ${c.description ? `<div class="item-description">${c.description}</div>` : ''}
                                    ${c.benefits && c.benefits.length > 0 ? `
                                        <div class="benefits">
                                            <h5>Benefits:</h5>
                                            <ul>
                                                ${c.benefits.map(b => `<li>${b}</li>`).join('')}
                                            </ul>
                                        </div>
                                    ` : ''}
                                </li>
                            `).join('')}
                        </ul>
                    `;
                    
                    capsSection.innerHTML = `
                        <div class="section-header">
                            <h3>Capabilities</h3>
                            <span class="section-toggle">▼</span>
                        </div>
                        <div class="section-content">
                            ${capsContent}
                        </div>
                    `;
                    
                    container.appendChild(capsSection);
                    
                    // Add click handlers
                    capsSection.querySelectorAll('.clickable-item').forEach(item => {
                        item.addEventListener('click', () => {
                            const nodeId = item.getAttribute('data-id');
                            if (nodeId) {
                                this.navigateToNode(nodeId);
                            }
                        });
                    });
                }
                
                // Technical Approach
                if (data.technical_approach) {
                    const techSection = document.createElement('div');
                    techSection.className = 'detail-section';
                    
                    let techContent = data.technical_approach;
                    if (typeof techContent === 'object') {
                        techContent = `
                            <h4>${techContent.name || 'Approach'}</h4>
                            <p>${techContent.description || ''}</p>
                            ${techContent.techniques && techContent.techniques.length > 0 ? `
                                <h5>Key Techniques:</h5>
                                <ul>
                                    ${techContent.techniques.map(t => `<li>${t}</li>`).join('')}
                                </ul>
                            ` : ''}
                        `;
                    }
                    
                    techSection.innerHTML = `
                        <div class="section-header">
                            <h3>Technical Approach</h3>
                            <span class="section-toggle">▼</span>
                        </div>
                        <div class="section-content">
                            ${techContent}
                        </div>
                    `;
                    
                    container.appendChild(techSection);
                }
                
                // Implementation Considerations
                if (data.implementation_considerations && data.implementation_considerations.length > 0) {
                    const implSection = document.createElement('div');
                    implSection.className = 'detail-section';
                    
                    let implContent = `
                        <div class="implementation-considerations">
                            ${data.implementation_considerations.map(ic => `
                                <div class="consideration-item">
                                    <h4>${ic.name || 'Consideration'}</h4>
                                    <p>${ic.description || ''}</p>
                                    ${ic.considerations && ic.considerations.length > 0 ? `
                                        <ul class="consideration-list">
                                            ${ic.considerations.map(c => `<li>${c}</li>`).join('')}
                                        </ul>
                                    ` : ''}
                                    ${ic.research_questions && ic.research_questions.length > 0 ? `
                                        <div class="research-questions">
                                            <h5>Research Questions:</h5>
                                            <ul>
                                                ${ic.research_questions.map(q => `<li>${q}</li>`).join('')}
                                            </ul>
                                        </div>
                                    ` : ''}
                                </div>
                            `).join('')}
                        </div>
                    `;
                    
                    implSection.innerHTML = `
                        <div class="section-header">
                            <h3>Implementation Considerations</h3>
                            <span class="section-toggle">▼</span>
                        </div>
                        <div class="section-content">
                            ${implContent}
                        </div>
                    `;
                    
                    container.appendChild(implSection);
                }
                
                // Evaluation Methods
                if (data.evaluation_methods && data.evaluation_methods.length > 0) {
                    const evalSection = document.createElement('div');
                    evalSection.className = 'detail-section';
                    
                    let evalContent = `
                        <ul class="evaluation-list">
                            ${data.evaluation_methods.map(em => `
                                <li>
                                    <strong>${em.name || 'Method'}</strong>
                                    ${em.description ? `<p>${em.description}</p>` : ''}
                                    ${em.metrics && em.metrics.length > 0 ? `
                                        <div class="metrics">
                                            <h5>Metrics:</h5>
                                            <ul>
                                                ${em.metrics.map(m => `<li>${m}</li>`).join('')}
                                            </ul>
                                        </div>
                                    ` : ''}
                                </li>
                            `).join('')}
                        </ul>
                    `;
                    
                    evalSection.innerHTML = `
                        <div class="section-header">
                            <h3>Evaluation Methods</h3>
                            <span class="section-toggle">▼</span>
                        </div>
                        <div class="section-content">
                            ${evalContent}
                        </div>
                    `;
                    
                    container.appendChild(evalSection);
                }
                
                // Cross Connections
                if (data.cross_connections && data.cross_connections.length > 0) {
                    const crossSection = document.createElement('div');
                    crossSection.className = 'detail-section';
                    
                    let crossContent = `
                        <ul class="cross-connections-list clickable-list">
                            ${data.cross_connections.map(c => `
                                <li data-id="${c.id}" class="clickable-item">
                                    <span class="node-type-badge ${c.type}">${this.capitalizeFirstLetter(c.type)}</span>
                                    <strong>${c.name}</strong>
                                    ${c.description ? `<div class="item-description">${c.description}</div>` : ''}
                                    ${c.relationship ? `<div class="relationship-description"><em>Relationship:</em> ${c.relationship}</div>` : ''}
                                </li>
                            `).join('')}
                        </ul>
                    `;
                    
                    crossSection.innerHTML = `
                        <div class="section-header">
                            <h3>Cross Connections</h3>
                            <span class="section-toggle">▼</span>
                        </div>
                        <div class="section-content">
                            ${crossContent}
                        </div>
                    `;
                    
                    container.appendChild(crossSection);
                    
                    // Add click handlers
                    crossSection.querySelectorAll('.clickable-item').forEach(item => {
                        item.addEventListener('click', () => {
                            const nodeId = item.getAttribute('data-id');
                            if (nodeId) {
                                this.navigateToNode(nodeId);
                            }
                        });
                    });
                }
            }
            
            setupSectionToggles() {
                // Add event listeners to all section toggles
                const toggles = document.querySelectorAll('.section-toggle');
                toggles.forEach(toggle => {
                    toggle.addEventListener('click', (event) => {
                        // Toggle the collapsed class on the clicked element
                        event.target.classList.toggle('collapsed');
                        
                        // Find the content section (next sibling to the section header)
                        const header = event.target.closest('.section-header');
                        const content = header.nextElementSibling;
                        
                        // Toggle visibility
                        if (content.style.display === 'none') {
                            content.style.display = 'block';
                        } else {
                            content.style.display = 'none';
                        }
                    });
                });
            }
            
            createHoverNameDisplay() {
                // Create a div for displaying node names on hover
                const nameDisplay = document.createElement('div');
                nameDisplay.id = 'hover-node-name';
                nameDisplay.style.cssText = `
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background-color: rgba(25, 25, 40, 0.85);
                    color: white;
                    padding: 15px 20px;
                    border-radius: 8px;
                    font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
                    z-index: 1000;
                    transition: opacity 0.2s ease;
                    opacity: 0;
                    pointer-events: none;
                    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
                    border: 1px solid rgba(200, 200, 255, 0.4);
                    max-width: 90%;
                    min-width: auto;
                    display: inline-block;
                    margin: 0 auto;
                `;
                
                // Add to DOM
                this.container.appendChild(nameDisplay);
                return nameDisplay;
            }
        }
        
        // Initialize visualization when the page loads
        window.addEventListener('load', () => {
            const visualization = new AIAlignmentVisualization();
        });
    </script>

    <!-- Add a timestamp query parameter to prevent caching -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Force reload of scripts and styles to prevent caching
            const scripts = document.querySelectorAll('script[src]');
            const links = document.querySelectorAll('link[rel="stylesheet"]');
            const timestamp = Date.now();
            
            scripts.forEach(script => {
                if (script.src) {
                    script.src = script.src + '?v=' + timestamp;
                }
            });
            
            links.forEach(link => {
                if (link.href) {
                    link.href = link.href + '?v=' + timestamp;
                }
            });
        });
    </script>
</body>
</html> 