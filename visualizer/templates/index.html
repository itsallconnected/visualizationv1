<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Alignment 3D Visualization</title>
    <!-- Google Fonts - Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- TWEEN.js for smooth animations -->
    <script src="https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@18.6.4/dist/tween.umd.js"></script>
    <!-- Our CSS -->
    <link rel="stylesheet" href="/static/styles.css">
    <!-- Node details renderer -->
    <script src="/static/node_details_renderer.js"></script>
</head>
<body>
    <div class="container">
        <!-- Visualization area -->
        <div id="visualization-container">
            <div id="scene-container"></div>
            
            <!-- Controls -->
            <div class="controls">
                <button id="zoom-in">Zoom In</button>
                <button id="zoom-out">Zoom Out</button>
                <button id="reset-view">Reset View</button>
                <button id="toggle-rotation">Toggle Rotation</button>
                <button id="expand-all">Expand All</button>
                <button id="collapse-all">Collapse All</button>
            </div>
            
            <!-- Legend -->
            <div class="legend">
                <h3>Node Types</h3>
                <div class="legend-item">
                    <span class="legend-color component-group"></span>
                    <span>Component Group</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color component"></span>
                    <span>Component</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color subcomponent"></span>
                    <span>Subcomponent</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color capability"></span>
                    <span>Capability</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color function"></span>
                    <span>Function</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color specification"></span>
                    <span>Specification</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color integration"></span>
                    <span>Integration</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color technique"></span>
                    <span>Technique</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color application"></span>
                    <span>Application</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color input"></span>
                    <span>Input</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color output"></span>
                    <span>Output</span>
                </div>
            </div>
        </div>
        
        <!-- Details panel -->
        <div id="details-panel">
            <div class="details-header">
                <h2 id="details-title">Select a node to view details</h2>
                <div id="breadcrumb-navigation" class="breadcrumb-container"></div>
                <div class="global-controls">
                    <button id="expand-collapse-all" class="action-button">Expand All</button>
                </div>
            </div>
            <div id="details-content" class="scrollable-content"></div>
            <div id="literature-references" class="literature-section">
                <h3>Literature References</h3>
                <div id="references-content" class="empty-section">No literature references available</div>
            </div>
        </div>
    </div>

    <!-- Three.js import map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.150.1/examples/jsm/"
            }
        }
    </script>

    <!-- Main visualization script -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { DragControls } from 'three/addons/controls/DragControls.js';
        
        // Main visualization class
        class AIAlignmentVisualization {
            constructor() {
                // Core THREE.js components
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;
                
                // Interaction and physics
                this.raycaster = null;
                this.mouse = null;
                this.clock = new THREE.Clock();
                
                // Graph data storage
                this.graphData = null;
                this.nodeDetails = new Map();
                
                // Visualization objects
                this.nodes = new Map();           // THREE.js meshes by node ID
                this.links = new Map();           // THREE.js line objects
                this.nodePositions = new Map();   // Current 3D positions of nodes
                this.expandedNodes = new Set();   // Tracks which nodes are expanded
                this.nodeAnimations = new Map();  // Animation properties for nodes
                this.nodeOrbits = new Map();      // Orbital patterns for child nodes
                
                // State management
                this.selectedNode = null;
                this.hoveredNode = null;
                this.isRotating = false;
                this.isActive = true;             // Controls if animation loop runs
                this.animationRunning = false;    // Tracks if animation has started
                this._processingExpansion = false; // Prevents concurrent expand/collapse operations
                
                // Performance
                this.frustumCulled = true;
                
                // Initialize the visualization
                this.init();
                this.setupEventListeners(); // Set up UI event listeners
                this.loadData();
            }
            
            init() {
                // Get container element
                this.container = document.getElementById('scene-container');
                if (!this.container) {
                    // Fallback to body if container not found
                    console.error("Container element 'scene-container' not found, using body as fallback");
                    this.container = document.body;
                    // Create a container div if using body as fallback
                    const containerDiv = document.createElement('div');
                    containerDiv.id = 'scene-container';
                    containerDiv.style.width = '100%';
                    containerDiv.style.height = '100vh';
                    document.body.appendChild(containerDiv);
                    this.container = containerDiv;
                }
                
                // Get container dimensions
                const width = this.container.clientWidth || window.innerWidth;
                const height = this.container.clientHeight || window.innerHeight;
                
                // Initialize scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x111111);
                
                // Initialize camera
                this.camera = new THREE.PerspectiveCamera(
                    60, 
                    width / height, 
                    1, 
                    10000
                );
                this.camera.position.z = 1000;
                
                // Initialize renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(width, height);
                this.container.appendChild(this.renderer.domElement);
                
                // Initialize controls
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                
                // Initialize raycaster for mouse interaction
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                
                // Create hover display
                this.hoverDisplay = this.createHoverDisplay();
                
                // Add lights
                const ambientLight = new THREE.AmbientLight(0x404040);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight.position.set(1, 1, 1);
                this.scene.add(directionalLight);
                
                // Create spherical container
                this.createSphericalContainer();
                
                // Set up window resize handler
                window.addEventListener('resize', () => this.onWindowResize());
                
                console.log("Visualization initialized");
            }
            
            // Method to properly start animation loop
            startAnimation() {
                if (!this.animationRunning) {
                    this.isActive = true;
                    this.animationRunning = true;
                    this.animate();
                    console.log("Animation loop started");
                }
            }
            
            // Method to properly stop animation loop
            stopAnimation() {
                this.isActive = false;
                this.animationRunning = false;
                console.log("Animation loop stopped");
            }
            
            loadData() {
                fetch('/api/graph')
                    .then(response => response.json())
                    .then(data => {
                        this.processData(data);
                        
                        // Find and expand the root node initially
                        const rootNode = this.graphData.nodes.find(node => !node.parent);
                        if (rootNode) {
                            this.expandedNodes.add(rootNode.id);
                        }
                        
                        // Get initially visible nodes
                        const visibleNodes = this.getVisibleNodes();
                        
                        // Position nodes based on hierarchy
                        this.positionNodes(visibleNodes);
                        
                        // Create visualization objects
                        this.createNodeObjects(visibleNodes);
                        this.createLinkObjects(this.getVisibleLinks(visibleNodes));
                        
                        // Set up node animations
                        this.setupNodeOrbits(visibleNodes);
                        
                        // Start animation loop
                        this.startAnimation();
                    })
                    .catch(error => console.error('Error loading data:', error));
            }
            
            processData(data) {
                console.log("Processing graph data:", data);
                
                // Store the graph data
                this.graphData = data;
                
                // Validate and normalize the data
                if (!this.graphData.nodes) {
                    console.error("Invalid graph data: missing nodes array");
                    this.graphData.nodes = [];
                }
                
                if (!this.graphData.links) {
                    console.error("Invalid graph data: missing links array");
                    this.graphData.links = [];
                }
                
                // Normalize links to ensure source and target are properly set
                this.graphData.links.forEach(link => {
                    if (typeof link.source === 'object' && link.source !== null) {
                        link.source = link.source.id || link.source;
                    }
                    
                    if (typeof link.target === 'object' && link.target !== null) {
                        link.target = link.target.id || link.target;
                    }
                });
                
                console.log(`Processed ${this.graphData.nodes.length} nodes and ${this.graphData.links.length} links`);
            }
            
            createHoverDisplay() {
                // Create the hover display element
                const hoverDisplay = document.createElement('div');
                hoverDisplay.id = 'hover-node-name';
                document.body.appendChild(hoverDisplay);
                
                // Set initial state
                hoverDisplay.style.opacity = '0';
                hoverDisplay.style.display = 'none';
                
                return hoverDisplay;
            }
            
            createSphericalContainer() {
                // Define the maximum radius based on the number of levels
                const maxRadius = this.calculateMaxSphereRadius();
                
                // Create a wireframe sphere to show the boundary
                const sphereGeometry = new THREE.SphereGeometry(maxRadius, 64, 32);
                const wireframe = new THREE.WireframeGeometry(sphereGeometry);
                const sphereMaterial = new THREE.LineBasicMaterial({ 
                    color: 0x333344,
                    transparent: true,
                    opacity: 0.2,
                    linewidth: 0.2
                });
                
                const sphere = new THREE.LineSegments(wireframe, sphereMaterial);
                sphere.name = 'boundingSphere';
                this.scene.add(sphere);
            }
            
            calculateMaxSphereRadius() {
                // This will be updated when data is loaded
                // Default initial radius
                return 500;
            }
            
            setupEventListeners() {
                console.log("Setting up event listeners");
                
                // Control buttons
                const zoomInButton = document.getElementById('zoom-in');
                const zoomOutButton = document.getElementById('zoom-out');
                const resetViewButton = document.getElementById('reset-view');
                const toggleRotationButton = document.getElementById('toggle-rotation');
                const expandAllButton = document.getElementById('expand-all');
                const collapseAllButton = document.getElementById('collapse-all');
                const detailsExpandAllButton = document.getElementById('expand-collapse-all');
                
                if (zoomInButton) {
                    zoomInButton.addEventListener('click', () => {
                        this.zoomIn();
                        this.cameraControlsNeedUpdate = true;
                    });
                }
                
                if (zoomOutButton) {
                    zoomOutButton.addEventListener('click', () => {
                        this.zoomOut();
                        this.cameraControlsNeedUpdate = true;
                    });
                }
                
                if (resetViewButton) {
                    resetViewButton.addEventListener('click', () => {
                        this.resetView();
                        this.cameraControlsNeedUpdate = true;
                    });
                }
                
                if (toggleRotationButton) {
                    toggleRotationButton.addEventListener('click', () => {
                        this.toggleRotation();
                    });
                }
                
                // Add expand-all button event listener
                if (expandAllButton) {
                    expandAllButton.addEventListener('click', () => {
                        this.expandAllNodes();
                    });
                }
                
                // Add collapse-all button event listener
                if (collapseAllButton) {
                    collapseAllButton.addEventListener('click', () => {
                        this.collapseAllNodes();
                    });
                }
                
                // Add details panel expand-all button event listener
                if (detailsExpandAllButton) {
                    detailsExpandAllButton.addEventListener('click', () => {
                        // Toggle between expand all and collapse all
                        if (detailsExpandAllButton.textContent === 'Expand All') {
                            this.expandAllNodes();
                            detailsExpandAllButton.textContent = 'Collapse All';
                        } else {
                            this.collapseAllNodes();
                            detailsExpandAllButton.textContent = 'Expand All';
                        }
                    });
                }
                
                // OrbitControls events
                if (this.controls) {
                    this.controls.addEventListener('change', () => {
                        this.cameraControlsNeedUpdate = true;
                    });
                }
                
                // Mouse move event for hover
                this.container.addEventListener('mousemove', this.onMouseMove.bind(this));
                
                // Click event
                this.container.addEventListener('click', this.onClick.bind(this));
                
                // Resize event
                window.addEventListener('resize', this.onWindowResize.bind(this));
                
                // Initialize the flag
                this.cameraControlsNeedUpdate = true;
            }
            
            getVisibleNodes() {
                // Start with the root node
                const visibleNodes = [];
                const processedNodes = new Set(); // To avoid duplicate processing
                
                // Find the root node
                const rootNode = this.graphData.nodes.find(node => node.level === 0);
                if (rootNode) {
                    visibleNodes.push(rootNode);
                    processedNodes.add(rootNode.id);
                }
                
                // Breadth-first traversal to ensure parent-child relationships are respected
                const queue = [rootNode];
                
                while (queue.length > 0) {
                    const currentNode = queue.shift();
                    
                    // Skip if node isn't expanded (except for root)
                    if (currentNode.level > 0 && !this.expandedNodes.has(currentNode.id)) {
                        continue;
                    }
                    
                    // Add children of expanded nodes
                    const children = this.graphData.nodes.filter(node => 
                        node.parent === currentNode.id
                    );
                    
                    children.forEach(child => {
                        if (!processedNodes.has(child.id)) {
                            visibleNodes.push(child);
                            processedNodes.add(child.id);
                            queue.push(child);
                        }
                    });
                }
                
                // Final safety check to ensure no orphaned nodes are included
                return visibleNodes.filter(node => 
                    node.level === 0 || 
                    (this.expandedNodes.has(node.parent) && processedNodes.has(node.parent))
                );
            }
            
            onMouseMove(event) {
                // Calculate mouse position in normalized device coordinates (-1 to +1)
                this.mouse.x = (event.clientX / this.container.clientWidth) * 2 - 1;
                this.mouse.y = -(event.clientY / this.container.clientHeight) * 2 + 1;
                
                // Update the picking ray with the camera and mouse position
                this.raycaster.setFromCamera(this.mouse, this.camera);
                
                // Find all intersected objects
                const intersects = this.raycaster.intersectObjects(this.scene.children, true);
                
                // Check if we're hovering over a node
                if (intersects.length > 0) {
                    // Find the first intersected node (not a line)
                    const intersectedNode = intersects.find(intersect => 
                        intersect.object.userData && 
                        intersect.object.userData.nodeId &&
                        intersect.object.type === 'Mesh'
                    );
                    
                    if (intersectedNode) {
                        const nodeId = intersectedNode.object.userData.nodeId;
                        const nodeData = this.graphData.nodes.find(n => n.id === nodeId);
                        
                        if (nodeData) {
                            // Show hover display
                            this.hoverDisplay.innerHTML = `
                                <div class="node-type">${this.capitalizeFirstLetter(nodeData.type.replace('_', ' '))}</div>
                                <div class="node-name">${nodeData.name}</div>
                            `;
                            this.hoverDisplay.style.display = 'block';
                            this.hoverDisplay.style.opacity = '1';
                            
                            // Position hover display at mouse position
                            const x = event.clientX;
                            const y = event.clientY - 40; // Offset above the cursor
                            
                            this.hoverDisplay.style.left = `${x}px`;
                            this.hoverDisplay.style.top = `${y}px`;
                            this.hoverDisplay.style.transform = 'translate(-50%, -100%)';
                            
                            // Set cursor to pointer
                            this.container.style.cursor = 'pointer';
                            return;
                        }
                    }
                }
                
                // If not hovering over a node, hide the display
                this.hoverDisplay.style.opacity = '0';
                this.hoverDisplay.style.display = 'none';
                this.container.style.cursor = 'default';
            }
            
            capitalizeFirstLetter(string) {
                if (!string) return '';
                return string.split(' ').map(word => {
                    return word.charAt(0).toUpperCase() + word.slice(1);
                }).join(' ');
            }
            
            getNodeColor(nodeType) {
                // Return colors based on node type
                const colors = {
                    'component_group': '#4A90E2',
                    'component': '#50C878',
                    'subcomponent': '#9B59B6',
                    'capability': '#E67E22',
                    'function': '#E74C3C',
                    'specification': '#F1C40F',
                    'integration': '#16A085',
                    'technique': '#2ECC71',
                    'application': '#3498DB',
                    'input': '#5499C7',
                    'output': '#F39C12'
                };
                
                return colors[nodeType] || '#CCCCCC'; // Default gray for unknown types
            }
            
            getNodeSize(nodeType, level = 0) {
                // Calculate size based on node type and level
                // Root node should be largest, with decreasing sizes as we move outward
                // But each type should have a specific size relative to its importance
                
                // Base sizes for different node types (larger than before)
                const baseSizes = {
                    'component_group': 18,
                    'component': 15,
                    'subcomponent': 12,
                    'capability': 10,
                    'function': 9,
                    'specification': 9,
                    'integration': 8,
                    'technique': 8,
                    'application': 8,
                    'input': 6,
                    'output': 7
                };
                
                // Get base size or default to 6
                const baseSize = baseSizes[nodeType] || 6;
                
                // Calculate level adjustment factor - higher levels get smaller
                const levelFactor = Math.max(0.6, 1 - (level * 0.05));
                
                // Apply level factor to base size
                return baseSize * levelFactor;
            }
            
            onClick(event) {
                // Calculate mouse position in normalized device coordinates (-1 to +1)
                this.mouse.x = (event.clientX / this.container.clientWidth) * 2 - 1;
                this.mouse.y = -(event.clientY / this.container.clientHeight) * 2 + 1;
                
                // Update the picking ray with the camera and mouse position
                this.raycaster.setFromCamera(this.mouse, this.camera);
                
                // Find all intersected objects
                const intersects = this.raycaster.intersectObjects(this.scene.children, true);
                
                // Check if we clicked on a node
                if (intersects.length > 0) {
                    // Find the first intersected node (not a line)
                    const intersectedNode = intersects.find(intersect => 
                        intersect.object.userData && 
                        intersect.object.userData.nodeId &&
                        intersect.object.type === 'Mesh'
                    );
                    
                    if (intersectedNode) {
                        const nodeId = intersectedNode.object.userData.nodeId;
                        const nodeData = this.graphData.nodes.find(n => n.id === nodeId);
                        
                        if (nodeData) {
                            console.log(`Clicked on node: ${nodeData.name} (${nodeData.id})`);
                            
                            // If the node has children, toggle expansion
                            if (nodeData.has_children) {
                                if (this.expandedNodes.has(nodeId)) {
                                    // Node is expanded, collapse it
                                    this.expandedNodes.delete(nodeId);
                                    this.recursivelyCollapseChildren(nodeId);
                                } else {
                                    // Node is collapsed, expand it
                                    this.expandedNodes.add(nodeId);
                                }
                                
                                // Update the visualization
                                const visibleNodes = this.getVisibleNodes();
                                this.positionNodes(visibleNodes);
                                this.createNodeObjects(visibleNodes);
                                this.createLinkObjects(this.getVisibleLinks(visibleNodes));
                                
                                // Update animations for newly visible nodes
                                this.setupNodeAnimations(visibleNodes);
                            }
                            
                            // Select the node to show details
                            this.selectNode(nodeData);
                            
                            // Mark camera controls for update
                            this.cameraControlsNeedUpdate = true;
                        }
                    }
                }
            }
            
            recursivelyCollapseChildren(nodeId) {
                console.log(`Collapsing children of node: ${nodeId}`);
                
                // Get all nodes that have this node as a parent
                const children = this.graphData.nodes.filter(n => n.parent === nodeId);
                
                // For each child
                children.forEach(child => {
                    // Remove from expanded nodes set
                    this.expandedNodes.delete(child.id);
                    console.log(`Collapsed node: ${child.id}`);
                    
                    // Recursively collapse its children
                    this.recursivelyCollapseChildren(child.id);
                });
                
                // Safety check to ensure all descendants are truly collapsed
                // This handles cases where the parent-child relationships might not be perfect
                const allDescendants = this.findAllDescendants(nodeId);
                allDescendants.forEach(descendantId => {
                    if (this.expandedNodes.has(descendantId)) {
                        console.log(`Force collapsing descendant: ${descendantId}`);
                        this.expandedNodes.delete(descendantId);
                    }
                });
            }
            
            // Helper method to find all descendants of a node regardless of direct parent links
            findAllDescendants(nodeId) {
                const descendants = new Set();
                
                // Helper function to recursively collect descendants
                const collectDescendants = (id) => {
                    // Find direct children
                    const children = this.graphData.nodes.filter(n => n.parent === id);
                    
                    // Add each child and its descendants
                    children.forEach(child => {
                        descendants.add(child.id);
                        collectDescendants(child.id);
                    });
                };
                
                // Start the recursive collection
                collectDescendants(nodeId);
                
                return Array.from(descendants);
            }
            
            cullNodesOutsideViewport() {
                // Skip if not using optimization
                if (!this.frustumCulled) return;
                
                // Get the camera frustum
                const frustum = new THREE.Frustum();
                const matrix = new THREE.Matrix4().multiplyMatrices(
                    this.camera.projectionMatrix,
                    this.camera.matrixWorldInverse
                );
                frustum.setFromProjectionMatrix(matrix);
                
                // Check each node against the frustum
                this.nodes.forEach((nodeMesh, nodeId) => {
                    if (nodeMesh.isInstancedNode) {
                        // For instanced nodes, we need to update their visibility differently
                        const instancedMesh = nodeMesh.userData.instancedMesh;
                        const instanceIndex = nodeMesh.userData.instanceIndex;
                        
                        // Skip if already processed this instanced mesh
                        if (instancedMesh.userData.frustumChecked) return;
                        
                        // Mark as processed
                        instancedMesh.userData.frustumChecked = true;
                        
                        // Check the whole instanced mesh bounding box
                        instancedMesh.geometry.computeBoundingBox();
                        const boundingBox = instancedMesh.geometry.boundingBox.clone();
                        boundingBox.applyMatrix4(instancedMesh.matrixWorld);
                        
                        // Set visibility based on whether it's in the frustum
                        instancedMesh.visible = frustum.intersectsBox(boundingBox);
                    } else {
                        // For individual meshes, just check position
                        const position = nodeMesh.position.clone();
                        nodeMesh.visible = frustum.containsPoint(position);
                    }
                });
                
                // Reset the frustum checked flag for next frame
                this.nodes.forEach(nodeMesh => {
                    if (nodeMesh.isInstancedNode && nodeMesh.userData.instancedMesh) {
                        nodeMesh.userData.instancedMesh.userData.frustumChecked = false;
                    }
                });
            }
            
            getVisibleLinks(visibleNodes) {
                // If no graph data or visibleNodes not provided, return empty array
                if (!this.graphData || !this.graphData.links || !visibleNodes) {
                    return [];
                }
                
                // Create a set of visible node IDs for faster lookup
                const nodeIds = new Set(visibleNodes.map(node => node.id));
                
                // Filter links where both source and target are visible
                return this.graphData.links.filter(link => {
                    const source = typeof link.source === 'object' ? link.source.id : link.source;
                    const target = typeof link.target === 'object' ? link.target.id : link.target;
                    return nodeIds.has(source) && nodeIds.has(target);
                });
            }
            
            positionNodes(nodes) {
                // Position the root node at the center
                const rootNode = nodes.find(node => node.level === 0);
                if (rootNode) {
                    this.nodePositions.set(rootNode.id, { x: 0, y: 0, z: 0 });
                }

                // Group nodes by level for better organization
                const nodesByLevel = new Map();
                const maxLevel = Math.max(...nodes.map(n => n.level));
                
                // Calculate the maximum radius for our bounding sphere
                const sphereRadius = 400 + (maxLevel * 50);
                
                // Update sphere container if it exists
                const boundingSphere = this.scene.getObjectByName('boundingSphere');
                if (boundingSphere) {
                    this.scene.remove(boundingSphere);
                    
                    const sphereGeometry = new THREE.SphereGeometry(sphereRadius, 64, 32);
                    const wireframe = new THREE.WireframeGeometry(sphereGeometry);
                    const sphereMaterial = new THREE.LineBasicMaterial({ 
                        color: 0x333344,
                        transparent: true,
                        opacity: 0.2,
                        linewidth: 0.2
                    });
                    
                    const newSphere = new THREE.LineSegments(wireframe, sphereMaterial);
                    newSphere.name = 'boundingSphere';
                    this.scene.add(newSphere);
                }
                
                // Group nodes by level
                nodes.forEach(node => {
                    if (!nodesByLevel.has(node.level)) {
                        nodesByLevel.set(node.level, []);
                    }
                    nodesByLevel.get(node.level).push(node);
                });

                // Place nodes by level and organizational hierarchy
                for (let level = 1; level <= maxLevel; level++) {
                    const levelNodes = nodesByLevel.get(level) || [];
                    if (levelNodes.length === 0) continue;
                    
                    // Group nodes by their parent
                    const nodesByParent = new Map();
                    levelNodes.forEach(node => {
                        if (!node.parent) return;
                        
                        if (!nodesByParent.has(node.parent)) {
                            nodesByParent.set(node.parent, []);
                        }
                        nodesByParent.get(node.parent).push(node);
                    });
                    
                    // Calculate level radius based on hyperbolic scaling
                    // As level increases, radius approaches the sphere boundary but never reaches it
                    const levelProgress = level / (maxLevel + 1); // +1 to ensure we don't reach 1.0
                    const levelRadius = sphereRadius * (1 - Math.pow(1 - levelProgress, 2));
                    
                    // Position each parent's children in 3D spherical distribution
                    nodesByParent.forEach((children, parentId) => {
                        const parentPos = this.nodePositions.get(parentId) || { x: 0, y: 0, z: 0 };
                        const childCount = children.length;
                        
                        // If only one child, place it directly out from parent
                        if (childCount === 1) {
                            const direction = new THREE.Vector3(
                                Math.random() - 0.5,
                                Math.random() - 0.5,
                                Math.random() - 0.5
                            ).normalize();
                            
                            const distance = levelRadius - Math.sqrt(parentPos.x * parentPos.x + parentPos.y * parentPos.y + parentPos.z * parentPos.z);
                            
                            this.nodePositions.set(children[0].id, {
                                x: parentPos.x + direction.x * distance,
                                y: parentPos.y + direction.y * distance,
                                z: parentPos.z + direction.z * distance
                            });
                            return;
                        }
                        
                        // For multiple children, distribute using Fibonacci spiral on sphere section
                        const parentToCenter = Math.sqrt(parentPos.x * parentPos.x + parentPos.y * parentPos.y + parentPos.z * parentPos.z);
                        const parentDirection = parentToCenter === 0 ? 
                            new THREE.Vector3(0, 1, 0) : 
                            new THREE.Vector3(parentPos.x / parentToCenter, parentPos.y / parentToCenter, parentPos.z / parentToCenter);
                        
                        // Create a basis for distributing points around parent direction
                        const upVector = Math.abs(parentDirection.y) > 0.9 ? 
                            new THREE.Vector3(1, 0, 0) : 
                            new THREE.Vector3(0, 1, 0);
                        
                        const rightVector = new THREE.Vector3().crossVectors(parentDirection, upVector).normalize();
                        const actualUpVector = new THREE.Vector3().crossVectors(rightVector, parentDirection).normalize();
                        
                        // Angle to spread children (narrower for deeper levels)
                        const spreadAngle = Math.PI / 2 * Math.pow(0.8, level - 1);
                        
                        // Position each child using spherical coordinates relative to parent direction
                        children.forEach((node, i) => {
                            // Fibonacci spiral distribution for even spacing on partial sphere
                            const phi = Math.acos(1 - 2 * (i + 0.5) / childCount);
                            const theta = Math.PI * (1 + Math.sqrt(5)) * (i + 0.5);
                            
                            // Convert to cartesian but limit to spread angle
                            const x = Math.sin(phi * spreadAngle) * Math.cos(theta);
                            const y = Math.sin(phi * spreadAngle) * Math.sin(theta);
                            const z = Math.cos(phi * spreadAngle);
                            
                            // Transform to parent-oriented basis
                            const localPos = new THREE.Vector3(
                                x * rightVector.x + y * actualUpVector.x + z * parentDirection.x,
                                x * rightVector.y + y * actualUpVector.y + z * parentDirection.y,
                                x * rightVector.z + y * actualUpVector.z + z * parentDirection.z
                            );
                            
                            // Calculate distance from center to maintain level radius
                            const distToParent = levelRadius - parentToCenter;
                            
                            // Set position
                            this.nodePositions.set(node.id, {
                                x: parentPos.x + localPos.x * distToParent,
                                y: parentPos.y + localPos.y * distToParent,
                                z: parentPos.z + localPos.z * distToParent
                            });
                        });
                    });
                }

                // Apply spacing to reduce node overlap but preserve the overall structure
                this.applyHyperbolicSpacing(nodes, sphereRadius);
            }
            
            applyHyperbolicSpacing(nodes, sphereRadius) {
                const minDistance = 25; // Minimum distance between nodes (increased to reduce overlap)
                const iterations = 5;   // Increased number of relaxation iterations
                
                // Cache parent-child relationships for quick lookup
                const childrenByParent = new Map();
                const parentByChild = new Map();
                
                nodes.forEach(node => {
                    if (node.parent) {
                        parentByChild.set(node.id, node.parent);
                        
                        if (!childrenByParent.has(node.parent)) {
                            childrenByParent.set(node.parent, []);
                        }
                        childrenByParent.get(node.parent).push(node.id);
                    }
                });
                
                for (let iter = 0; iter < iterations; iter++) {
                    // Copy positions to avoid modifying during iteration
                    const positionsCopy = new Map();
                    for (const [id, pos] of this.nodePositions.entries()) {
                        positionsCopy.set(id, { x: pos.x, y: pos.y, z: pos.z });
                    }
                    
                    // Repulsion forces - prevent node overlap
                    for (let i = 0; i < nodes.length; i++) {
                        const nodeA = nodes[i];
                        if (!this.nodePositions.has(nodeA.id)) continue;
                        
                        const posA = positionsCopy.get(nodeA.id);
                        
                        for (let j = i + 1; j < nodes.length; j++) {
                            const nodeB = nodes[j];
                            if (!this.nodePositions.has(nodeB.id)) continue;
                            
                            const posB = positionsCopy.get(nodeB.id);
                            
                            // Calculate distance
                            const dx = posB.x - posA.x;
                            const dy = posB.y - posA.y;
                            const dz = posB.z - posA.z;
                            const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                            
                            // Skip if nodes are far enough apart
                            if (distance >= minDistance) continue;
                            
                            // Skip if one node is the parent of the other - manage those with attraction
                            const isParentChild = 
                                parentByChild.get(nodeA.id) === nodeB.id || 
                                parentByChild.get(nodeB.id) === nodeA.id;
                            
                            if (isParentChild) continue;
                            
                            // Calculate required movement - less movement for deeper levels
                            const levelFactorA = 1 / Math.max(1, nodeA.level);
                            const levelFactorB = 1 / Math.max(1, nodeB.level);
                            
                            const moveDistance = (minDistance - distance) / 2;
                            
                            // Avoid divide by zero
                            if (distance > 0.001) {
                                const moveX = (dx / distance) * moveDistance;
                                const moveY = (dy / distance) * moveDistance;
                                const moveZ = (dz / distance) * moveDistance;
                                
                                // Apply movement with level-based dampening
                                const posAFinal = this.nodePositions.get(nodeA.id);
                                const posBFinal = this.nodePositions.get(nodeB.id);
                                
                                posAFinal.x -= moveX * levelFactorA;
                                posAFinal.y -= moveY * levelFactorA;
                                posAFinal.z -= moveZ * levelFactorA;
                                
                                posBFinal.x += moveX * levelFactorB;
                                posBFinal.y += moveY * levelFactorB;
                                posBFinal.z += moveZ * levelFactorB;
                            }
                        }
                    }
                    
                    // Attraction forces - maintain parent-child distances
                    for (const [childId, parentId] of parentByChild.entries()) {
                        if (!this.nodePositions.has(childId) || !this.nodePositions.has(parentId)) continue;
                        
                        const childPos = this.nodePositions.get(childId);
                        const parentPos = this.nodePositions.get(parentId);
                        
                        // Calculate current distance
                        const dx = childPos.x - parentPos.x;
                        const dy = childPos.y - parentPos.y; 
                        const dz = childPos.z - parentPos.z;
                        const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                        
                        // Calculate ideal distance based on level
                        const childNode = nodes.find(n => n.id === childId);
                        const targetDistance = 50 + 20 * childNode.level; // Larger spacing for deeper levels
                        
                        // Only adjust if significantly off target
                        if (Math.abs(distance - targetDistance) > 10) {
                            // Avoid divide by zero
                            if (distance > 0.001) {
                                const factor = targetDistance / distance;
                                const newDx = dx * factor;
                                const newDy = dy * factor;
                                const newDz = dz * factor;
                                
                                // Move child to new position
                                childPos.x = parentPos.x + newDx;
                                childPos.y = parentPos.y + newDy;
                                childPos.z = parentPos.z + newDz;
                            }
                        }
                    }
                    
                    // Constraint forces - keep nodes within sphere and maintain radial distance
                    for (const node of nodes) {
                        if (!this.nodePositions.has(node.id)) continue;
                        
                        const pos = this.nodePositions.get(node.id);
                        const distFromCenter = Math.sqrt(pos.x * pos.x + pos.y * pos.y + pos.z * pos.z);
                        
                        // Skip root node
                        if (node.level === 0) continue;
                        
                        // Calculate target radius based on level
                        const maxLevel = Math.max(...nodes.map(n => n.level));
                        const levelProgress = node.level / (maxLevel + 1);
                        const targetRadius = sphereRadius * (0.3 + 0.65 * levelProgress); // More progressive scaling
                        
                        // Only adjust if significantly off target radius
                        if (Math.abs(distFromCenter - targetRadius) > 15) {
                            if (distFromCenter > 0.001) {
                                const factor = targetRadius / distFromCenter;
                                pos.x *= factor;
                                pos.y *= factor;
                                pos.z *= factor;
                            } else {
                                // Handle zero case with random placement on sphere
                                const phi = Math.random() * Math.PI * 2;
                                const theta = Math.random() * Math.PI;
                                
                                pos.x = targetRadius * Math.sin(theta) * Math.cos(phi);
                                pos.y = targetRadius * Math.sin(theta) * Math.sin(phi);
                                pos.z = targetRadius * Math.cos(theta);
                            }
                        }
                    }
                }
            }
            
            isDescendantOf(node, ancestorId, allNodes) {
                if (node.parent === ancestorId) return true;
                
                let currentNode = node;
                while (currentNode.parent) {
                    const parentNode = allNodes.find(n => n.id === currentNode.parent);
                    if (!parentNode) break;
                    
                    if (parentNode.id === ancestorId) return true;
                    currentNode = parentNode;
                }
                
                return false;
            }
            
            createNodeObjects(nodes) {
                // Clear existing nodes first
                this.nodes.forEach(node => {
                    this.scene.remove(node);
                });
                this.nodes.clear();
                
                // Create a shared geometry map to reuse geometries
                const geometries = new Map();
                
                // Create individual mesh for each node
                nodes.forEach(nodeData => {
                    const size = this.getNodeSize(nodeData.type, nodeData.level);
                    const geometryKey = `${nodeData.type}-${size}`;
                    
                    // Reuse geometry if already created
                    if (!geometries.has(geometryKey)) {
                        geometries.set(geometryKey, new THREE.SphereGeometry(size, 32, 32));
                    }
                    
                    const geometry = geometries.get(geometryKey);
                    const color = this.getNodeColor(nodeData.type);
                    const material = new THREE.MeshPhongMaterial({
                        color: color,
                        shininess: 80,
                        emissive: new THREE.Color(color).multiplyScalar(0.2)
                    });
                    
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.userData = { 
                        node: nodeData,
                        nodeId: nodeData.id  // Important: Add nodeId explicitly for raycasting
                    };
                    mesh.frustumCulled = true; // Enable culling for performance
                    
                    if (this.nodePositions.has(nodeData.id)) {
                        const pos = this.nodePositions.get(nodeData.id);
                        mesh.position.set(pos.x, pos.y, pos.z);
                    }
                    
                    // Add to scene
                    this.scene.add(mesh);
                    this.nodes.set(nodeData.id, mesh);
                });
            }
            
            createLinkObjects(links) {
                // Clear existing links
                this.links.forEach(link => {
                    this.scene.remove(link);
                    if (link.geometry) link.geometry.dispose();
                    if (link.material) link.material.dispose();
                });
                this.links.clear();
                
                // Handle case where links parameter is not provided
                const linksToUse = links || this.getVisibleLinks([]);
                
                // Create shared materials map to reduce material instances
                const materials = new Map();
                
                linksToUse.forEach(link => {
                    // Handle potentially varying link structure - source and target might be objects or strings
                    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                    const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                    
                    const sourceNode = this.nodes.get(sourceId);
                    const targetNode = this.nodes.get(targetId);
                    
                    if (!sourceNode || !targetNode) return;
                    
                    // Get positions
                    const sourcePos = sourceNode.position.clone();
                    const targetPos = targetNode.position.clone();
                    
                    // Determine color and opacity based on node types
                    let color, opacity, lineWidth;
                    
                    // Get source and target node types
                    const sourceType = sourceNode.userData.node.type;
                    const targetType = targetNode.userData.node.type;
                    
                    // Use a consistent grey color for all links
                    color = 0xb4b4b4; // Light grey color
                    
                    // Set opacity based on link importance - now much more subtle
                    if (targetType === 'component_group' || targetType === 'component') {
                        opacity = 0.15;
                        lineWidth = 0.5;
                    } else if (targetType === 'subcomponent' || targetType === 'capability') {
                        opacity = 0.12;
                        lineWidth = 0.35;
                    } else {
                        opacity = 0.1;
                        lineWidth = 0.2;
                    }
                    
                    // Special case for output links
                    if (targetType === 'output') {
                        opacity = 0.18;
                        lineWidth = 0.5;
                    }
                    
                    // Get or create material
                    const materialKey = `${color}-${opacity}`;
                    if (!materials.has(materialKey)) {
                        materials.set(materialKey, new THREE.LineBasicMaterial({
                            color: color,
                            transparent: true,
                            opacity: opacity,
                            linewidth: lineWidth
                        }));
                    }
                    
                    const material = materials.get(materialKey);
                    
                    // Create a curved path between nodes
                    // For nearby nodes, use straight lines
                    // For distant nodes, add curvature
                    const distance = sourcePos.distanceTo(targetPos);
                    let linkGeometry;
                    
                    if (distance < 50) {
                        // For close nodes, use straight line
                        const points = [sourcePos, targetPos];
                        linkGeometry = new THREE.BufferGeometry().setFromPoints(points);
                    } else {
                        // For distant nodes, create curved link
                        const midPoint = sourcePos.clone().add(targetPos).multiplyScalar(0.5);
                        
                        // Add curve perpendicular to line connecting nodes
                        const lineDirection = targetPos.clone().sub(sourcePos).normalize();
                        
                        // Create perpendicular direction (in 3D space)
                        const perpendicular = new THREE.Vector3(
                            -lineDirection.z,
                            lineDirection.y,
                            lineDirection.x
                        ).normalize();
                        
                        // Curve height based on distance
                        const curveHeight = Math.min(distance * 0.2, 50);
                        
                        // Control point is midpoint raised in perpendicular direction
                        const controlPoint = midPoint.clone().add(
                            perpendicular.clone().multiplyScalar(curveHeight)
                        );
                        
                        // Create quadratic curve
                        const curve = new THREE.QuadraticBezierCurve3(
                            sourcePos,
                            controlPoint,
                            targetPos
                        );
                        
                        // Sample points along curve
                        const points = curve.getPoints(20);
                        linkGeometry = new THREE.BufferGeometry().setFromPoints(points);
                    }
                    
                    // Create the line
                    const line = new THREE.Line(linkGeometry, material);
                    line.userData = {
                        source: sourceId,
                        target: targetId,
                        type: link.type || "default"
                    };
                    
                    // Generate a unique ID for the link if not present
                    const linkId = link.id || `${sourceId}-${targetId}`;
                    this.links.set(linkId, line);
                    
                    // Add to scene
                    this.scene.add(line);
                });
                
                console.log(`Created ${this.links.size} links`);
            }
            
            // Control functions
            zoomIn() {
                const targetZ = this.camera.position.z * 0.8;
                new TWEEN.Tween(this.camera.position)
                    .to({ z: targetZ }, 300)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();
            }
            
            zoomOut() {
                const targetZ = this.camera.position.z * 1.2;
                new TWEEN.Tween(this.camera.position)
                    .to({ z: targetZ }, 300)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();
            }
            
            resetView() {
                new TWEEN.Tween(this.camera.position)
                    .to({ x: 0, y: 0, z: 500 }, 500)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();
                    
                new TWEEN.Tween(this.scene.rotation)
                    .to({ x: 0, y: 0, z: 0 }, 500)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();
                    
                this.controls.reset();
            }
            
            toggleRotation() {
                this.isRotating = !this.isRotating;
            }
            
            // Expand all nodes in the graph
            expandAllNodes() {
                console.log("Expanding all nodes...");
                
                // Guard against multiple calls
                if (this._processingExpansion) {
                    console.log("Already processing expansion/collapse, please wait");
                    return;
                }
                
                this._processingExpansion = true;
                
                try {
                    // Add all nodes to the expanded set
                    for (const node of this.graphData.nodes) {
                        this.expandedNodes.add(node.id);
                    }
                    
                    // Update the visualization
                    const visibleNodes = this.getVisibleNodes();
                    const visibleLinks = this.getVisibleLinks(visibleNodes);
                    
                    // Position nodes and update visual elements
                    this.positionNodes(visibleNodes);
                    this.createNodeObjects(visibleNodes);
                    this.createLinkObjects(visibleLinks);
                    this.setupNodeAnimations(visibleNodes);
                    
                    console.log(`Expanded to ${visibleNodes.length} nodes and ${visibleLinks.length} links`);
                } catch (error) {
                    console.error("Error expanding all nodes:", error);
                } finally {
                    // Clear the processing flag after a short delay
                    setTimeout(() => {
                        this._processingExpansion = false;
                    }, 500);
                }
            }
            
            // Collapse all nodes except the root
            collapseAllNodes() {
                console.log("Collapsing all nodes...");
                
                // Guard against multiple calls
                if (this._processingExpansion) {
                    console.log("Already processing expansion/collapse, please wait");
                    return;
                }
                
                this._processingExpansion = true;
                
                try {
                    // Find the root node
                    const rootNode = this.graphData.nodes.find(node => node.level === 0);
                    if (!rootNode) {
                        console.error("Root node not found");
                        return;
                    }
                    
                    // Reset expanded nodes completely
                    this.expandedNodes.clear();
                    
                    // Only add root node to expanded set
                    this.expandedNodes.add(rootNode.id);
                    
                    // Remove all visual nodes except the root
                    this.nodes.forEach((nodeMesh, nodeId) => {
                        if (nodeId !== rootNode.id) {
                            this.scene.remove(nodeMesh);
                            if (nodeMesh.geometry) nodeMesh.geometry.dispose();
                            if (nodeMesh.material) nodeMesh.material.dispose();
                        }
                    });
                    
                    // Clear the nodes collection except for root
                    const rootMesh = this.nodes.get(rootNode.id);
                    this.nodes.clear();
                    if (rootMesh) this.nodes.set(rootNode.id, rootMesh);
                    
                    // Remove all links
                    this.links.forEach(link => {
                        this.scene.remove(link);
                        if (link.geometry) link.geometry.dispose();
                        if (link.material) link.material.dispose();
                    });
                    this.links.clear();
                    
                    // Reset node animations
                    this.nodeAnimations.clear();
                    
                    // Get visible nodes - should be just the root now
                    const visibleNodes = this.getVisibleNodes();
                    
                    // Re-create necessary objects
                    this.positionNodes(visibleNodes);
                    this.createNodeObjects(visibleNodes);
                    this.createLinkObjects(this.getVisibleLinks(visibleNodes));
                    this.setupNodeAnimations(visibleNodes);
                    
                    // Focus on root
                    if (rootNode) {
                        const position = this.nodePositions.get(rootNode.id);
                        if (position) {
                            this.navigateToPosition(position.x, position.y, position.z);
                        }
                    }
                    
                    console.log(`Collapsed to ${visibleNodes.length} nodes`);
                } catch (error) {
                    console.error("Error collapsing all nodes:", error);
                } finally {
                    // Clear the processing flag after a short delay
                    setTimeout(() => {
                        this._processingExpansion = false;
                    }, 500);
                }
            }
            
            // Add new method to force expanding children for a given specification node
            forceExpandChildren(specificationId) {
                console.log(`Force expanding children for specification: ${specificationId}`);
                
                if (!this.graphData || !this.graphData.nodes) {
                    console.error("No graph data available");
                    return;
                }
                
                // First ensure the specification node is in our graph data
                const specNode = this.graphData.nodes.find(n => n.id === specificationId);
                if (!specNode) {
                    console.error(`Specification node not found: ${specificationId}`);
                    return;
                }
                
                // Make sure the specification node and all its ancestors are expanded
                this.ensureNodeVisible(specNode);
                
                // Find all direct children of this specification node
                const childNodes = this.graphData.nodes.filter(n => n.parent === specificationId);
                
                // Expand each child
                childNodes.forEach(child => {
                    this.expandedNodes.add(child.id);
                    
                    // Recursively expand grandchildren
                    const grandchildren = this.graphData.nodes.filter(n => n.parent === child.id);
                    grandchildren.forEach(grandchild => {
                        this.expandedNodes.add(grandchild.id);
                    });
                });
                
                // Update visualization
                const visibleNodes = this.getVisibleNodes();
                this.positionNodes(visibleNodes);
                this.createNodeObjects(visibleNodes);
                this.createLinkObjects(this.getVisibleLinks(visibleNodes));
                
                // Update animations for newly visible nodes
                this.setupNodeAnimations(visibleNodes);
                
                // Select the specification node to focus on it
                this.selectNode(specNode);
            }
            
            // New method to specifically select the root node using a dedicated endpoint
            async selectRootNode(rootNode) {
                // Update UI to show selected node details
                const detailsTitle = document.getElementById('details-title');
                const detailsContent = document.getElementById('details-content');
                
                // Set title
                detailsTitle.textContent = rootNode.name;
                
                // Show loading indicator
                detailsContent.innerHTML = `
                    <div class="loading-indicator">
                        <div class="spinner"></div>
                        <span>Loading details...</span>
                    </div>
                `;
                
                try {
                    // Use the dedicated root endpoint
                    console.log("Fetching root node details from dedicated endpoint");
                    const response = await fetch('/api/root');
                    
                    if (!response.ok) {
                        console.error(`Error loading root details: ${response.status} ${response.statusText}`);
                        detailsContent.innerHTML = `
                            <div class="error-message">
                                <h3>Error</h3>
                                <p>Could not load root details: ${response.statusText}</p>
                                <p>Status: ${response.status}</p>
                            </div>
                        `;
                        return;
                    }
                    
                    const detailsData = await response.json();
                    
                    if (detailsData.error) {
                        detailsContent.innerHTML = `
                            <div class="error-message">
                                <h3>Error</h3>
                                <p>${detailsData.error}</p>
                            </div>
                        `;
                        return;
                    }
                    
                    this.displayNodeDetails(detailsData);
                    this.updateBreadcrumbs(rootNode.id);
                    
                    // Track selected node
                    this.selectedNode = rootNode;
                    
                    // Highlight the selected node
                    this.highlightSelectedNode(rootNode.id);
                } catch (error) {
                    console.error(`Error in selectRootNode: ${error}`);
                    detailsContent.innerHTML = `
                        <div class="error-message">
                            <h3>Error</h3>
                            <p>An unexpected error occurred: ${error.message}</p>
                        </div>
                    `;
                }
            }
            
            // Helper method to find node data in backend data
            async findNodeInBackendData(nodeId) {
                if (!nodeId) return null;
                
                // First check if it's a direct node in graphData
                const node = this.graphData.nodes.find(n => n.id === nodeId);
                if (!node) return null;
                
                try {
                    // Special handling for root node
                    if (nodeId === "ai-alignment" || node.level === 0) {
                        console.log("Using root endpoint for node data");
                        const response = await fetch('/api/root');
                        
                        if (!response.ok) {
                            console.error(`Error fetching root data: ${response.status} ${response.statusText}`);
                            return null;
                        }
                        
                        const data = await response.json();
                        console.log("Successfully fetched root data:", data);
                        return data;
                    }
                    
                    // For all other node types, fetch the complete data from the backend
                    console.log(`Fetching complete data for node: ${nodeId}`);
                    const response = await fetch(`/api/details/${nodeId}`);
                    
                    if (!response.ok) {
                        console.error(`Error fetching node data: ${response.status} ${response.statusText}`);
                        return null;
                    }
                    
                    const data = await response.json();
                    console.log(`Successfully fetched data for ${nodeId}:`, data);
                    return data;
                } catch (error) {
                    console.error(`Error fetching node data: ${error}`);
                    return null;
                }
            }
            
            // Method to select a node and display its details
            async selectNode(nodeData) {
                if (!nodeData) return;
                
                console.log(`Selecting node: ${nodeData.name} (${nodeData.id})`);
                
                // Update selected node reference
                this.selectedNode = nodeData;
                
                // Find and highlight the node visually
                const nodeMesh = this.nodes.get(nodeData.id);
                if (nodeMesh) {
                    // Reset all node materials first
                    this.nodes.forEach((mesh, id) => {
                        if (mesh.material && mesh.material.emissive) {
                            mesh.material.emissive.setScalar(0.2);
                            mesh.scale.set(1, 1, 1);
                        }
                    });
                    
                    // Highlight the selected node
                    if (nodeMesh.material && nodeMesh.material.emissive) {
                        // Don't change the base color, only increase emissive intensity
                        nodeMesh.material.emissiveIntensity = 0.5;
                        nodeMesh.scale.set(1.2, 1.2, 1.2);
                    }
                    
                    // Move camera to focus on this node
                    const position = this.nodePositions.get(nodeData.id);
                    if (position) {
                        this.navigateToPosition(position.x, position.y, position.z);
                    }
                }
                
                // Update UI with node details
                const detailsTitle = document.getElementById('details-title');
                const detailsContent = document.getElementById('details-content');
                
                if (detailsTitle && detailsContent) {
                    // Set title
                    detailsTitle.textContent = nodeData.name;
                    
                    // Show loading indicator
                    detailsContent.innerHTML = `
                        <div class="loading-indicator">
                            <div class="spinner"></div>
                            <span>Loading details...</span>
                        </div>
                    `;
                    
                    try {
                        // Try to get complete node data
                        const fullNodeData = await this.findNodeInBackendData(nodeData.id);
                        
                        if (fullNodeData) {
                            // Display the complete node details
                            this.displayNodeDetails(fullNodeData);
                            
                            // Update breadcrumbs
                            this.updateBreadcrumbs(nodeData.id);
                        } else {
                            // If API fetch fails, use the basic node data we have
                            this.displayNodeDetails(nodeData);
                        }
                    } catch (error) {
                        console.error(`Error fetching node details: ${error}`);
                        // Fall back to basic data
                        this.displayNodeDetails(nodeData);
                    }
                }
                
                // Highlight the node in the visualization
                this.highlightSelectedNode(nodeData.id);
            }
            
            // Display node details in the details panel
            displayNodeDetails(nodeData) {
                const detailsContent = document.getElementById('details-content');
                
                if (!detailsContent) {
                    console.error("Details content element not found");
                    return;
                }
                
                try {
                    // Use the node details renderer to generate the HTML
                    const html = nodeDetailsRenderer.renderNodeDetails(nodeData);
                    
                    // Set the content
                    detailsContent.innerHTML = html;
                    
                    // Update literature references if available
                    this.updateLiteratureReferences(nodeData);
                    
                    // Add event listeners to clickable items
                    this.setupClickableItems(detailsContent);
                } catch (error) {
                    console.error("Error rendering node details:", error);
                    detailsContent.innerHTML = `
                        <div class="error-message">
                            <h3>Error</h3>
                            <p>An error occurred while rendering node details: ${error.message}</p>
                        </div>
                    `;
                }
            }
            
            // Setup click events for clickable items in the details panel
            setupClickableItems(container) {
                // Find all clickable items
                const clickableItems = container.querySelectorAll('.clickable-item, .subcomponent-link, .function-link, .technique-link');
                
                // Add click handler to each
                clickableItems.forEach(item => {
                    item.addEventListener('click', () => {
                        const nodeId = item.dataset.nodeId;
                        if (!nodeId) return;
                        
                        // Find node in the graph data
                        const nodeData = this.graphData.nodes.find(n => n.id === nodeId);
                        if (nodeData) {
                            // Navigate to this node
                            this.navigateToNode(nodeData);
                        } else {
                            console.warn(`Node with ID ${nodeId} not found in graph data`);
                        }
                    });
                });
            }
            
            // Update literature references in the side panel
            updateLiteratureReferences(nodeData) {
                const referencesContainer = document.getElementById('references-content');
                if (!referencesContainer) return;
                
                // Clear existing content
                referencesContainer.innerHTML = '';
                
                // Check for literature references based on node type
                let references = [];
                
                // For component group, look in literature.references
                if (nodeData.type === 'component_group' && nodeData.literature && Array.isArray(nodeData.literature.references)) {
                    references = nodeData.literature.references;
                }
                // For component, look in literature
                else if (nodeData.type === 'component' && nodeData.literature) {
                    references = nodeData.literature.references || [];
                }
                // For subcomponent, look in literature.references
                else if (nodeData.type === 'subcomponent' && nodeData.literature && Array.isArray(nodeData.literature.references)) {
                    references = nodeData.literature.references;
                }
                // For capability, look in supported_by_literature
                else if (nodeData.type === 'capability' && Array.isArray(nodeData.supported_by_literature)) {
                    references = nodeData.supported_by_literature;
                }
                
                // Handle empty references
                if (!references || references.length === 0) {
                    referencesContainer.innerHTML = '<div class="empty-section">No literature references available</div>';
                    return;
                }
                
                // Display references
                references.forEach(ref => {
                    let refHtml = '';
                    
                    // Handle both reference objects and reference strings
                    if (typeof ref === 'string') {
                        refHtml = `
                            <div class="reference-item">
                                <div class="ref-header">${ref}</div>
                                <div class="ref-body">Reference identifier</div>
                            </div>
                        `;
                    } else {
                        // Format authors if it's an array
                        const authors = Array.isArray(ref.authors) ? ref.authors.join(', ') : (ref.authors || '');
                        const year = ref.year ? `(${ref.year})` : '';
                        const venue = ref.venue ? `<div>${ref.venue}</div>` : '';
                        const url = ref.url ? `<a href="${ref.url}" target="_blank">View publication</a>` : '';
                        
                        refHtml = `
                            <div class="reference-item">
                                <div class="ref-header">${ref.title || 'Untitled reference'}</div>
                                <div class="ref-body">
                                    ${authors} ${year}
                                    ${venue}
                                    ${url}
                                </div>
                            </div>
                        `;
                    }
                    
                    referencesContainer.innerHTML += refHtml;
                });
            }
            
            // Update breadcrumbs showing the path to the selected node
            async updateBreadcrumbs(nodeId) {
                const breadcrumbContainer = document.querySelector('.breadcrumb-container');
                if (!breadcrumbContainer) return;
                
                try {
                    // Fetch hierarchy path from API
                    const response = await fetch(`/api/hierarchy-path/${nodeId}`);
                    if (!response.ok) {
                        console.error(`Failed to fetch hierarchy path: ${response.statusText}`);
                        return;
                    }
                    
                    const pathData = await response.json();
                    if (!pathData.path || !pathData.path.length) {
                        console.error('Invalid path data received');
                        return;
                    }
                    
                    // Build breadcrumb HTML
                    let breadcrumbHtml = '';
                    
                    pathData.path.forEach((node, index) => {
                        // For each node in the path
                        const isLast = index === pathData.path.length - 1;
                        
                        if (isLast) {
                            // Current node (last in path)
                            breadcrumbHtml += `<div class="breadcrumb-item">${node.name}</div>`;
                        } else {
                            // Ancestor node (clickable)
                            breadcrumbHtml += `
                                <div class="breadcrumb-item clickable" data-node-id="${node.id}">${node.name}</div>
                                <div class="breadcrumb-separator">›</div>
                            `;
                        }
                    });
                    
                    // Set breadcrumb content
                    breadcrumbContainer.innerHTML = breadcrumbHtml;
                    
                    // Add click handlers to breadcrumb items
                    const clickableItems = breadcrumbContainer.querySelectorAll('.breadcrumb-item.clickable');
                    clickableItems.forEach(item => {
                        item.addEventListener('click', () => {
                            const nodeId = item.dataset.nodeId;
                            if (nodeId) {
                                const nodeData = this.graphData.nodes.find(n => n.id === nodeId);
                                if (nodeData) {
                                    this.navigateToNode(nodeData);
                                }
                            }
                        });
                    });
                    
                } catch (error) {
                    console.error(`Error updating breadcrumbs: ${error}`);
                }
            }
            
            // Highlight the selected node in the visualization
            highlightSelectedNode(nodeId) {
                // Reset all nodes to normal appearance
                this.nodes.forEach((nodeMesh, id) => {
                    // Skip if this is an instanced node (those are handled differently)
                    if (nodeMesh.isInstancedNode) return;
                    
                    // Reset to original color
                    const nodeData = this.graphData.nodes.find(n => n.id === id);
                    if (nodeData) {
                        const color = this.getNodeColor(nodeData.type);
                        nodeMesh.material.color.set(color);
                        
                        // Reset size
                        nodeMesh.scale.set(1, 1, 1);
                    }
                });
                
                // Highlight the selected node
                const selectedNode = this.nodes.get(nodeId);
                if (selectedNode && !selectedNode.isInstancedNode) {
                    // Make it brighter and slightly larger
                    selectedNode.material.color.set(0xFFFFFF);
                    selectedNode.scale.set(1.3, 1.3, 1.3);
                }
            }
            
            // Navigate to a specific node in the visualization
            navigateToNode(nodeData) {
                if (!nodeData) return;
                
                // Make sure node is visible (expanded parent chain)
                this.ensureNodeVisible(nodeData);
                
                // Select the node
                this.selectNode(nodeData);
                
                // Get node position
                const position = this.nodePositions.get(nodeData.id);
                if (position) {
                    // Navigate camera to node
                    this.navigateToPosition(position.x, position.y, position.z);
                }
            }
            
            // Ensure a node is visible by expanding all of its parent nodes
            ensureNodeVisible(nodeData) {
                if (!nodeData || !nodeData.id) return;
                
                console.log(`Ensuring node ${nodeData.id} is visible`);
                
                // Add this node to expanded nodes
                this.expandedNodes.add(nodeData.id);
                
                // If this node has a parent, ensure it's visible too
                if (nodeData.parent) {
                    const parentNode = this.graphData.nodes.find(n => n.id === nodeData.parent);
                    if (parentNode) {
                        this.ensureNodeVisible(parentNode);
                    }
                }
            }
            
            // Navigate camera to a specific position
            navigateToPosition(x, y, z) {
                // Animate camera movement to position
                const target = new THREE.Vector3(x, y, z);
                const distance = 200; // Distance from target
                
                // Calculate new camera position (slightly offset from target)
                const newPosition = new THREE.Vector3(
                    x + distance,
                    y + distance * 0.5,
                    z + distance
                );
                
                // Calculate distance for animation duration - faster for shorter moves
                const currentPos = this.camera.position;
                const moveDistance = currentPos.distanceTo(newPosition);
                const duration = Math.min(1200, Math.max(400, moveDistance * 1.5));
                
                // Animate to new position
                new TWEEN.Tween(this.camera.position)
                    .to({ x: newPosition.x, y: newPosition.y, z: newPosition.z }, duration)
                    .easing(TWEEN.Easing.Cubic.Out)
                    .onUpdate(() => {
                        this.cameraControlsNeedUpdate = true;
                    })
                    .start();
                
                // Set controls target
                new TWEEN.Tween(this.controls.target)
                    .to({ x, y, z }, duration)
                    .easing(TWEEN.Easing.Cubic.Out)
                    .onUpdate(() => {
                        this.cameraControlsNeedUpdate = true;
                    })
                    .start();
            }
            
            // Animation loop with performance optimizations
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Skip rendering if the visualization isn't active
                if (!this.isActive) return;
                
                const time = performance.now() * 0.001; // Convert to seconds
                
                // Update TWEEN animations
                TWEEN.update();
                
                // Update camera controls - only when needed
                if (this.controls && this.cameraControlsNeedUpdate) {
                    this.controls.update();
                    this.cameraControlsNeedUpdate = false;
                }
                
                // Performance optimization: Check if we need to perform updates this frame
                const now = performance.now();
                const nodeCount = this.nodes.size;
                
                // Calculate update frequency based on node count - fewer updates for more nodes
                let updateInterval = 16; // 60fps for small numbers of nodes
                
                if (nodeCount > 100) updateInterval = 33;      // 30fps for moderate nodes
                if (nodeCount > 300) updateInterval = 50;      // 20fps for lots of nodes
                if (nodeCount > 600) updateInterval = 100;     // 10fps for huge numbers of nodes
                if (nodeCount > 1000) updateInterval = 200;    // 5fps for extreme numbers of nodes
                
                // Only update if enough time has passed
                if (!this._lastAnimationUpdate || now - this._lastAnimationUpdate > updateInterval) {
                    this._lastAnimationUpdate = now;
                    
                    // Detect if we have too many nodes and temporarily disable animations
                    const animationsDisabled = nodeCount > 1000;
                    
                    // Update node animations if not disabled
                    if (!animationsDisabled) {
                        this.updateNodeAnimations(time);
                    }
                    
                    // Only update links infrequently for better performance - frequency based on node count
                    if (!this._linkUpdateCounter) this._linkUpdateCounter = 0;
                    this._linkUpdateCounter++;
                    
                    const linkUpdateThreshold = nodeCount > 300 ? 10 : (nodeCount > 100 ? 5 : 3);
                    
                    if (this._linkUpdateCounter >= linkUpdateThreshold) {
                        this._linkUpdateCounter = 0;
                        
                        // Optimize link updates - don't update every single link when we have many nodes
                        if (nodeCount > 500) {
                            this.updateCriticalLinkPositions(); // Only update important links
                        } else {
                            this.updateLinkPositions();
                        }
                    }
                }
                
                // Render the scene
                this.renderer.render(this.scene, this.camera);
            }
            
            // For large node counts, only update the most important links
            updateCriticalLinkPositions() {
                // Get the visible nodes close to the camera
                const cameraPos = this.camera.position;
                const visibleLinks = Array.from(this.links.values())
                    .filter(link => {
                        const sourceNode = this.nodes.get(link.userData.source);
                        const targetNode = this.nodes.get(link.userData.target);
                        
                        if (!sourceNode || !targetNode) return false;
                        
                        // Calculate distance to camera
                        const avgPos = new THREE.Vector3()
                            .addVectors(sourceNode.position, targetNode.position)
                            .multiplyScalar(0.5);
                            
                        const distToCamera = avgPos.distanceTo(cameraPos);
                        
                        // Only update links that are close to the camera or have moved significantly
                        return distToCamera < 500;
                    });
                
                // Only update a subset of links each frame for better performance
                const linksToUpdate = visibleLinks.slice(0, 100); // Limit to 100 links per update
                
                // Update only these critical links
                for (const link of linksToUpdate) {
                    const { sourceId, targetId } = link.userData;
                    
                    const sourceNode = this.nodes.get(sourceId);
                    const targetNode = this.nodes.get(targetId);
                    
                    if (!sourceNode || !targetNode) continue;
                    
                    const sourcePos = sourceNode.position.clone();
                    const targetPos = targetNode.position.clone();
                    
                    // Simple and fast - just update endpoints for most links
                    const points = [sourcePos, targetPos];
                    link.geometry.setFromPoints(points);
                    link.geometry.attributes.position.needsUpdate = true;
                }
            }
            
            // Window resize handler
            onWindowResize() {
                // Update camera aspect ratio
                this.camera.aspect = this.container.clientWidth / this.container.clientHeight;
                this.camera.updateProjectionMatrix();
                
                // Update renderer size
                this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
            }
            
            setupNodeOrbits(nodes) {
                // Create orbital patterns for nodes
                this.nodeOrbits = new Map();
                
                // Setup animations for nodes (which replaces the orbits concept)
                this.setupNodeAnimations(nodes);
            }
            
            setupNodeAnimations(nodes) {
                // Create animation data for nodes
                this.nodeAnimations = new Map();
                
                nodes.forEach(node => {
                    // Skip animations for certain node types
                    if (node.level === 0) return; // Don't animate root
                    
                    // Create animation parameters based on node type and level
                    const amplitude = Math.max(0.5, 5 - node.level * 0.5); // Higher levels have smaller movement
                    const speed = 0.2 + Math.random() * 0.3; // Random speed for natural movement
                    const phase = Math.random() * Math.PI * 2; // Random starting phase
                    const direction = new THREE.Vector3(
                        Math.random() - 0.5,
                        Math.random() - 0.5,
                        Math.random() - 0.5
                    ).normalize();
                    
                    this.nodeAnimations.set(node.id, {
                        originalPosition: this.nodePositions.get(node.id) 
                            ? { ...this.nodePositions.get(node.id) } 
                            : { x: 0, y: 0, z: 0 },
                        amplitude,
                        speed,
                        phase,
                        direction
                    });
                });
            }
            
            updateNodeAnimations(time) {
                // If no nodes should be animated, return
                if (!this.nodeAnimations || this.nodeAnimations.size === 0) return;
                
                // Update positions for animated nodes
                this.nodeAnimations.forEach((animation, nodeId) => {
                    const nodeMesh = this.nodes.get(nodeId);
                    if (!nodeMesh) return;
                    
                    const { originalPosition, amplitude, speed, phase, direction } = animation;
                    
                    // Calculate oscillation factor
                    const oscillation = amplitude * Math.sin(time * speed + phase);
                    
                    // Apply movement in the node's assigned direction while preserving original position
                    nodeMesh.position.x = originalPosition.x + direction.x * oscillation;
                    nodeMesh.position.y = originalPosition.y + direction.y * oscillation;
                    nodeMesh.position.z = originalPosition.z + direction.z * oscillation;
                    
                    // Update any connected links if needed
                    // We don't need to update link positions because they use the node mesh positions directly
                });
                
                // Update link positions that involve animated nodes
                // This should ensure links properly follow the animated nodes
                this.links.forEach(link => {
                    const sourceId = link.userData.source;
                    const targetId = link.userData.target;
                    
                    // Skip if this isn't a curved link (those need geometry updates)
                    if (link.geometry.type !== 'BufferGeometry') return;
                    
                    // Only update if source or target is being animated
                    if (!this.nodeAnimations.has(sourceId) && !this.nodeAnimations.has(targetId)) return;
                    
                    const sourceNode = this.nodes.get(sourceId);
                    const targetNode = this.nodes.get(targetId);
                    
                    if (!sourceNode || !targetNode) return;
                    
                    // For straight lines, just update the points
                    if (link.geometry.attributes.position.count <= 2) {
                        const points = [sourceNode.position, targetNode.position];
                        link.geometry.setFromPoints(points);
                    } else {
                        // For curved lines, regenerate the curve with the current positions
                        const sourcePos = sourceNode.position.clone();
                        const targetPos = targetNode.position.clone();
                        const distance = sourcePos.distanceTo(targetPos);
                        
                        // Only recreate the curve if it's a longer distance
                        if (distance >= 50) {
                            const midPoint = sourcePos.clone().add(targetPos).multiplyScalar(0.5);
                            const lineDirection = targetPos.clone().sub(sourcePos).normalize();
                            
                            // Create perpendicular direction
                            const perpendicular = new THREE.Vector3(
                                -lineDirection.z,
                                lineDirection.y,
                                lineDirection.x
                            ).normalize();
                            
                            // Curve height based on distance
                            const curveHeight = Math.min(distance * 0.2, 50);
                            
                            // Control point
                            const controlPoint = midPoint.clone().add(
                                perpendicular.clone().multiplyScalar(curveHeight)
                            );
                            
                            // Create new curve
                            const curve = new THREE.QuadraticBezierCurve3(
                                sourcePos,
                                controlPoint,
                                targetPos
                            );
                            
                            // Sample points along curve
                            const points = curve.getPoints(20);
                            link.geometry.setFromPoints(points);
                        }
                    }
                    
                    // Mark geometry as needing update
                    link.geometry.attributes.position.needsUpdate = true;
                });
            }
            
            updateLinkPositions() {
                for (const [id, link] of this.links.entries()) {
                    const { sourceId, targetId } = link.userData;
                    
                    const sourceNode = this.nodes.get(sourceId);
                    const targetNode = this.nodes.get(targetId);
                    
                    if (!sourceNode || !targetNode) continue;
                    
                    const sourcePos = sourceNode.position.clone();
                    const targetPos = targetNode.position.clone();
                    const distance = sourcePos.distanceTo(targetPos);
                    
                    // Use curved links for longer distances
                    if (distance >= 50 && link.geometry.type === 'BufferGeometry') {
                        // Create a curved link using a bezier curve
                        const midPoint = new THREE.Vector3().addVectors(sourcePos, targetPos).multiplyScalar(0.5);
                        const lineDirection = new THREE.Vector3().subVectors(targetPos, sourcePos).normalize();
                        
                        // Create a perpendicular direction for the control point
                        const perpendicular = new THREE.Vector3(
                            -lineDirection.z,
                            lineDirection.y,
                            lineDirection.x
                        ).normalize();
                        
                        // Set curve height based on distance
                        const curveHeight = Math.min(distance * 0.2, 50);
                        
                        // Create control point
                        const controlPoint = midPoint.clone().add(
                            perpendicular.clone().multiplyScalar(curveHeight)
                        );
                        
                        // Create quadratic bezier curve
                        const curve = new THREE.QuadraticBezierCurve3(
                            sourcePos,
                            controlPoint,
                            targetPos
                        );
                        
                        // Set geometry from curve points
                        const points = curve.getPoints(20);
                        link.geometry.setFromPoints(points);
                    } else {
                        // Create straight line for shorter distances
                        const points = [sourcePos, targetPos];
                        link.geometry.setFromPoints(points);
                    }
                    
                    // Mark geometry as needing update
                    link.geometry.attributes.position.needsUpdate = true;
                }
            }
        }
        
        // Initialize visualization when page loads
        window.addEventListener('DOMContentLoaded', () => {
            const visualization = new AIAlignmentVisualization();
        });
    </script>
</body>
</html>