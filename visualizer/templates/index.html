<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Alignment 3D Visualization</title>
    <!-- Google Fonts - Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- TWEEN.js for smooth animations -->
    <script src="https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@18.6.4/dist/tween.umd.js"></script>
    <!-- Our CSS -->
    <link rel="stylesheet" href="/static/styles.css">
</head>
<body>
    <div class="container">
        <!-- Visualization area -->
        <div id="visualization-container">
            <div id="scene-container"></div>
            
            <!-- Controls -->
            <div class="controls">
                <button id="zoom-in">Zoom In</button>
                <button id="zoom-out">Zoom Out</button>
                <button id="reset-view">Reset View</button>
                <button id="toggle-rotation">Toggle Rotation</button>
            </div>
            
            <!-- Legend -->
            <div class="legend">
                <h3>Node Types</h3>
                <div class="legend-item">
                    <span class="legend-color component-group"></span>
                    <span>Component Group</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color component"></span>
                    <span>Component</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color subcomponent"></span>
                    <span>Subcomponent</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color capability"></span>
                    <span>Capability</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color function"></span>
                    <span>Function</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color specification"></span>
                    <span>Specification</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color integration"></span>
                    <span>Integration</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color technique"></span>
                    <span>Technique</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color application"></span>
                    <span>Application</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color input"></span>
                    <span>Input</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color output"></span>
                    <span>Output</span>
                </div>
            </div>
        </div>
        
        <!-- Details panel -->
        <div id="details-panel">
            <div class="details-header">
                <h2 id="details-title">Select a node to view details</h2>
                <div id="breadcrumb-navigation" class="breadcrumb-container"></div>
                <div class="global-controls">
                    <button id="expand-collapse-all" class="action-button">Expand All</button>
                </div>
            </div>
            <div id="details-content" class="scrollable-content"></div>
            <div id="literature-references" class="literature-section">
                <h3>Literature References</h3>
                <div id="references-content" class="empty-section">No literature references available</div>
            </div>
        </div>
    </div>

    <!-- Three.js import map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.150.1/examples/jsm/"
            }
        }
    </script>

    <!-- Main visualization script -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { DragControls } from 'three/addons/controls/DragControls.js';
        
        // Main visualization class
        class AIAlignmentVisualization {
            constructor() {
                // Core properties
                this.container = document.getElementById('scene-container');
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;
                this.raycaster = null;
                this.mouse = null;
                this.clock = new THREE.Clock();
                
                // Node management
                this.nodes = new Map(); // Three.js node objects by ID
                this.links = new Map(); // Three.js link objects
                this.graphData = null; // Data from API
                this.expandedNodes = new Set(); // Tracks which nodes are expanded
                this.selectedNode = null; // Currently selected node
                this.nodePositions = new Map(); // Positions of nodes
                this.hoverDisplay = null; // Element for hover text
                
                // Animation state
                this.isRotating = false;
                this.isDragging = false;
                
                // Initialize
                this.init();
                this.setupEventListeners();
                this.loadData();
            }
            
            init() {
                // Setup Three.js scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x0f1015);
                
                // Setup renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.container.appendChild(this.renderer.domElement);
                
                // Setup camera
                this.camera = new THREE.PerspectiveCamera(
                    60, 
                    this.container.clientWidth / this.container.clientHeight, 
                    0.1, 
                    10000
                );
                this.camera.position.z = 500;
                
                // Setup controls
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.25;
                
                // Raycaster for interaction
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                
                // Add lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
                directionalLight.position.set(1, 1, 1);
                this.scene.add(directionalLight);
                
                const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight2.position.set(-1, -1, -1);
                this.scene.add(directionalLight2);
                
                // Create hover display
                this.hoverDisplay = this.createHoverDisplay();
                
                // Start animation loop
                this.animate();
                
                // Handle window resize
                window.addEventListener('resize', () => this.onWindowResize());
            }
            
            setupEventListeners() {
                // Control buttons
                document.getElementById('zoom-in').addEventListener('click', () => this.zoomIn());
                document.getElementById('zoom-out').addEventListener('click', () => this.zoomOut());
                document.getElementById('reset-view').addEventListener('click', () => this.resetView());
                document.getElementById('toggle-rotation').addEventListener('click', () => this.toggleRotation());
                
                // Mouse events
                this.container.addEventListener('mousemove', (event) => this.onMouseMove(event));
                this.container.addEventListener('click', (event) => this.onClick(event));
            }
            
            loadData() {
                fetch('/api/graph')
                    .then(response => response.json())
                    .then(data => {
                        console.log("Received graph data:", data);
                        this.graphData = data;
                        
                        // Log node counts by level for debugging
                        const nodesByLevel = {};
                        data.nodes.forEach(node => {
                            if (!nodesByLevel[node.level]) {
                                nodesByLevel[node.level] = 0;
                            }
                            nodesByLevel[node.level]++;
                        });
                        
                        console.log("Nodes by level in data:");
                        for (const level in nodesByLevel) {
                            console.log(`Level ${level}: ${nodesByLevel[level]} nodes`);
                        }
                        
                        // Initialize graph with root node
                        this.initializeGraph();
                    })
                    .catch(error => {
                        console.error('Error loading graph data:', error);
                        document.getElementById('details-content').innerHTML = `
                            <div class="error-message">
                                <h3>Error Loading Data</h3>
                                <p>${error.message || 'Could not load visualization data'}</p>
                            </div>
                        `;
                    });
            }
            
            initializeGraph() {
                if (!this.graphData || !this.graphData.nodes) {
                    console.error("No graph data available");
                    return;
                }

                // Start with just the root node
                const rootNode = this.graphData.nodes.find(node => node.level === 0);
                if (rootNode) {
                    // Mark root as expanded
                    this.expandedNodes.add(rootNode.id);
                    
                    // Get visible nodes and links
                    const visibleNodes = this.getVisibleNodes();
                    const visibleLinks = this.getVisibleLinks(visibleNodes);
                    
                    console.log(`Initializing graph with ${visibleNodes.length} nodes and ${visibleLinks.length} links`);
                    
                    // Position and create visual elements
                    this.positionNodes(visibleNodes);
                    this.createNodeObjects(visibleNodes);
                    this.createLinkObjects(visibleLinks);
                    
                    // Auto-select the root node but use the dedicated root endpoint
                    this.selectRootNode(rootNode);
                } else {
                    console.error("No root node found in graph data");
                }
            }
            
            getVisibleNodes() {
                // Only return nodes that should be visible based on expanded state
                return this.graphData.nodes.filter(node => {
                    // The root node is always visible
                    if (node.level === 0) return true;
                    
                    // Direct children of root (level 1) are visible when root is expanded
                    if (node.level === 1) return this.expandedNodes.has('ai-alignment');
                    
                    // If parent is expanded, this node is visible
                    const parentNode = this.graphData.nodes.find(n => n.id === node.parent);
                    if (!parentNode) return false;
                    
                    // Check parent is expanded
                    const isParentExpanded = this.expandedNodes.has(node.parent);
                    
                    // Special case for outputs attached to applications
                    if (node.type === 'output') {
                        // If this output belongs to an application (parent is application), check if the application is expanded
                        const parentIsApp = parentNode.type === 'application';
                        if (parentIsApp) {
                            return this.expandedNodes.has(node.parent);
                        }
                    }
                    
                    return isParentExpanded;
                });
            }
            
            getVisibleLinks(visibleNodes) {
                // Create a set of visible node IDs for faster lookup
                const nodeIds = new Set(visibleNodes.map(node => node.id));
                
                // Filter links where both source and target are visible
                return this.graphData.links.filter(link => {
                    const source = typeof link.source === 'object' ? link.source.id : link.source;
                    const target = typeof link.target === 'object' ? link.target.id : link.target;
                    return nodeIds.has(source) && nodeIds.has(target);
                });
            }
            
            positionNodes(nodes) {
                // Position the root node at the center
                const rootNode = nodes.find(node => !node.parent);
                if (rootNode) {
                    this.nodePositions.set(rootNode.id, { x: 0, y: 0, z: 0 });
                }

                // Group nodes by level for better organization
                const nodesByLevel = new Map();
                const maxLevel = Math.max(...nodes.map(n => n.level));
                
                nodes.forEach(node => {
                    if (!nodesByLevel.has(node.level)) {
                        nodesByLevel.set(node.level, []);
                    }
                    nodesByLevel.get(node.level).push(node);
                });

                // Calculate base radius for each level based on total nodes and level
                const calculateLevelRadius = (level) => {
                    const nodesInLevel = nodesByLevel.get(level)?.length || 0;
                    const baseRadius = 100; // Base radius for first level
                    const levelSpacing = 80; // Space between levels
                    const nodeSizeAtLevel = this.getNodeSize('component', level) * 3; // Use component size as reference
                    
                    // Calculate radius based on number of nodes and their size
                    const minCircumference = nodesInLevel * nodeSizeAtLevel * 2;
                    const radiusFromNodes = minCircumference / (2 * Math.PI);
                    
                    // Use the larger of the two radii to ensure proper spacing
                    return Math.max(baseRadius + (level * levelSpacing), radiusFromNodes);
                };

                // Position nodes level by level
                for (let level = 1; level <= maxLevel; level++) {
                    const nodesAtLevel = nodesByLevel.get(level) || [];
                    if (nodesAtLevel.length === 0) continue;

                    const radius = calculateLevelRadius(level);
                    
                    // Group nodes by their parent for better clustering
                    const nodesByParent = new Map();
                    nodesAtLevel.forEach(node => {
                        if (!nodesByParent.has(node.parent)) {
                            nodesByParent.set(node.parent, []);
                        }
                        nodesByParent.get(node.parent).push(node);
                    });

                    // Position each parent's children in their own sector of the sphere
                    let processedParentCount = 0;
                    const totalParents = nodesByParent.size;
                    
                    nodesByParent.forEach((children, parentId) => {
                        const parentAngle = (processedParentCount / totalParents) * Math.PI * 2;
                        const sectorSize = (1 / totalParents) * Math.PI * 2;
                        const parentPos = this.nodePositions.get(parentId) || { x: 0, y: 0, z: 0 };
                        
                        // Position children within their sector
                        children.forEach((node, index) => {
                            const angleInSector = parentAngle + (index / children.length) * sectorSize;
                            const phi = Math.acos(-1 + (2 * (index + 0.5)) / (children.length + 1));
                            
                            // Calculate position with offset from parent
                            const x = parentPos.x + radius * Math.sin(phi) * Math.cos(angleInSector);
                            const y = parentPos.y + radius * Math.sin(phi) * Math.sin(angleInSector);
                            const z = parentPos.z + radius * Math.cos(phi);
                            
                            this.nodePositions.set(node.id, { x, y, z });
                        });
                        
                        processedParentCount++;
                    });
                }

                // Apply force-directed spacing with stronger repulsion
                this.applyForceDirectedSpacing(nodes, {
                    iterations: 50,
                    repulsionStrength: 150,
                    minDistance: 40
                });
            }
            
            applyForceDirectedSpacing(nodes, options = {}) {
                const {
                    iterations = 50,
                    repulsionStrength = 150,
                    minDistance = 40,
                    damping = 0.8
                } = options;

                // Use TypedArrays for better performance
                const positions = new Float32Array(nodes.length * 3);
                const velocities = new Float32Array(nodes.length * 3);
                const forces = new Float32Array(nodes.length * 3);
                
                // Create node index mapping
                const nodeIndices = new Map();
                nodes.forEach((node, index) => {
                    nodeIndices.set(node.id, index);
                    const pos = this.nodePositions.get(node.id) || { x: 0, y: 0, z: 0 };
                    positions[index * 3] = pos.x;
                    positions[index * 3 + 1] = pos.y;
                    positions[index * 3 + 2] = pos.z;
                });

                // Spatial grid for optimization
                const gridSize = minDistance * 2;
                
                for (let iter = 0; iter < iterations; iter++) {
                    forces.fill(0);
                    
                    // Create spatial grid
                    const spatialGrid = new Map();
                    nodes.forEach((node, i) => {
                        const x = Math.floor(positions[i * 3] / gridSize);
                        const y = Math.floor(positions[i * 3 + 1] / gridSize);
                        const z = Math.floor(positions[i * 3 + 2] / gridSize);
                        const key = `${x},${y},${z}`;
                        if (!spatialGrid.has(key)) spatialGrid.set(key, []);
                        spatialGrid.get(key).push(i);
                    });

                    // Calculate forces
                    nodes.forEach((nodeA, i) => {
                        const x = Math.floor(positions[i * 3] / gridSize);
                        const y = Math.floor(positions[i * 3 + 1] / gridSize);
                        const z = Math.floor(positions[i * 3 + 2] / gridSize);
                        
                        // Check neighboring cells
                        for (let dx = -1; dx <= 1; dx++) {
                            for (let dy = -1; dy <= 1; dy++) {
                                for (let dz = -1; dz <= 1; dz++) {
                                    const key = `${x + dx},${y + dy},${z + dz}`;
                                    const cellNodes = spatialGrid.get(key);
                                    if (!cellNodes) continue;
                                    
                                    cellNodes.forEach(j => {
                                        if (i === j) return;
                                        
                                        const dx = positions[i * 3] - positions[j * 3];
                                        const dy = positions[i * 3 + 1] - positions[j * 3 + 1];
                                        const dz = positions[i * 3 + 2] - positions[j * 3 + 2];
                                        const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                                        
                                        if (distance === 0) return;
                                        
                                        // Calculate minimum distance based on node sizes
                                        const minDist = Math.max(
                                            minDistance,
                                            (this.getNodeSize(nodeA.type) + this.getNodeSize(nodes[j].type)) * 2
                                        );
                                        
                                        if (distance < minDist) {
                                            const force = repulsionStrength * (1 - distance / minDist);
                                            const fx = (dx / distance) * force;
                                            const fy = (dy / distance) * force;
                                            const fz = (dz / distance) * force;
                                            
                                            forces[i * 3] += fx;
                                            forces[i * 3 + 1] += fy;
                                            forces[i * 3 + 2] += fz;
                                        }
                                    });
                                }
                            }
                        }
                        
                        // Add containment force to maintain spherical structure
                        const distFromCenter = Math.sqrt(
                            positions[i * 3] * positions[i * 3] +
                            positions[i * 3 + 1] * positions[i * 3 + 1] +
                            positions[i * 3 + 2] * positions[i * 3 + 2]
                        );
                        
                        const levelRadius = this.calculateLevelRadius(nodeA.level);
                        const containmentStrength = 0.1;
                        
                        if (distFromCenter > levelRadius) {
                            const force = containmentStrength * (distFromCenter - levelRadius);
                            forces[i * 3] -= (positions[i * 3] / distFromCenter) * force;
                            forces[i * 3 + 1] -= (positions[i * 3 + 1] / distFromCenter) * force;
                            forces[i * 3 + 2] -= (positions[i * 3 + 2] / distFromCenter) * force;
                        }
                    });

                    // Update positions
                    let maxForce = 0;
                    nodes.forEach((node, i) => {
                        const idx = i * 3;
                        
                        // Update velocity with damping
                        velocities[idx] = (velocities[idx] + forces[idx]) * damping;
                        velocities[idx + 1] = (velocities[idx + 1] + forces[idx + 1]) * damping;
                        velocities[idx + 2] = (velocities[idx + 2] + forces[idx + 2]) * damping;
                        
                        // Apply velocity
                        positions[idx] += velocities[idx];
                        positions[idx + 1] += velocities[idx + 1];
                        positions[idx + 2] += velocities[idx + 2];
                        
                        // Update node positions
                        this.nodePositions.set(node.id, {
                            x: positions[idx],
                            y: positions[idx + 1],
                            z: positions[idx + 2]
                        });
                        
                        // Track maximum force
                        maxForce = Math.max(maxForce, Math.sqrt(
                            forces[idx] * forces[idx] +
                            forces[idx + 1] * forces[idx + 1] +
                            forces[idx + 2] * forces[idx + 2]
                        ));
                    });
                    
                    // Break if forces are small enough
                    if (maxForce < 0.1) break;
                }
            }
            
            calculateLevelRadius(level) {
                const baseRadius = 100;
                const levelSpacing = 80;
                return baseRadius + (level * levelSpacing);
            }
            
            calculateMinSpacing(nodes) {
                // Calculate minimum spacing needed between nodes based on their sizes
                let maxSize = 0;
                for (const node of nodes) {
                    const size = this.getNodeSize(node.type);
                    maxSize = Math.max(maxSize, size);
                }
                // Scale padding based on node size - smaller nodes get less padding
                const scaleFactor = maxSize > 20 ? 3.0 : (maxSize > 10 ? 2.5 : 2.0);
                return maxSize * scaleFactor;
            }
            
            ensureMinSpacing(position, siblings, minSpacing, currentIndex) {
                // Ensure minimum spacing from sibling nodes
                let finalPos = { ...position };
                let attempts = 0;
                const maxAttempts = 10;
                
                while (attempts < maxAttempts) {
                    let hasCollision = false;
                    
                    // Check distance from all siblings
                    for (let i = 0; i < siblings.length; i++) {
                        if (i === currentIndex) continue;
                        
                        const siblingPos = this.nodePositions.get(siblings[i].id);
                        if (!siblingPos) continue;
                        
                        const distance = Math.sqrt(
                            Math.pow(finalPos.x - siblingPos.x, 2) +
                            Math.pow(finalPos.y - siblingPos.y, 2) +
                            Math.pow(finalPos.z - siblingPos.z, 2)
                        );
                        
                        if (distance < minSpacing) {
                            hasCollision = true;
                            // Move away from collision
                            const direction = {
                                x: finalPos.x - siblingPos.x,
                                y: finalPos.y - siblingPos.y,
                                z: finalPos.z - siblingPos.z
                            };
                            const length = Math.sqrt(
                                direction.x * direction.x +
                                direction.y * direction.y +
                                direction.z * direction.z
                            );
                            
                            if (length > 0) {
                                finalPos.x += (direction.x / length) * (minSpacing - distance);
                                finalPos.y += (direction.y / length) * (minSpacing - distance);
                                finalPos.z += (direction.z / length) * (minSpacing - distance);
                            }
                        }
                    }
                    
                    if (!hasCollision) break;
                    attempts++;
                }
                
                return finalPos;
            }
            
            getOrbitRadius(level) {
                // Base radius increases with level
                return 100 + (level * 50);
            }
            
            createNodeObjects(nodes) {
                // Clear existing nodes first
                this.nodes.forEach(node => {
                    this.scene.remove(node);
                });
                this.nodes.clear();
                
                // Create shared geometries for each node type/size
                const geometries = new Map();
                
                // Process all nodes at once but reuse geometries for better performance
                nodes.forEach(nodeData => {
                    const size = this.getNodeSize(nodeData.type, nodeData.level);
                    const geometryKey = `${nodeData.type}-${size}`;
                    
                    // Reuse geometry if already created
                    if (!geometries.has(geometryKey)) {
                        geometries.set(geometryKey, new THREE.SphereGeometry(size, 32, 32));
                    }
                    
                    const geometry = geometries.get(geometryKey);
                    const color = this.getNodeColor(nodeData.type);
                    const material = new THREE.MeshPhongMaterial({
                        color: color,
                        shininess: 80,
                        emissive: new THREE.Color(color).multiplyScalar(0.2)
                    });
                    
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.userData = { node: nodeData };
                    
                    if (this.nodePositions.has(nodeData.id)) {
                        const pos = this.nodePositions.get(nodeData.id);
                        mesh.position.set(pos.x, pos.y, pos.z);
                    } else {
                        mesh.position.set(
                            (Math.random() - 0.5) * 200,
                            (Math.random() - 0.5) * 200,
                            (Math.random() - 0.5) * 200
                        );
                    }
                    
                    this.scene.add(mesh);
                    this.nodes.set(nodeData.id, mesh);
                });
            }
            
            createLinkObjects(links) {
                // Clear existing links
                this.links.forEach(link => {
                    this.scene.remove(link);
                });
                this.links.clear();
                
                // Create new link objects
                for (const linkData of links) {
                    const sourceId = typeof linkData.source === 'object' ? linkData.source.id : linkData.source;
                    const targetId = typeof linkData.target === 'object' ? linkData.target.id : linkData.target;
                    
                    // Get source and target nodes
                    const sourceNode = this.nodes.get(sourceId);
                    const targetNode = this.nodes.get(targetId);
                    
                    if (!sourceNode || !targetNode) continue;
                    
                    // Create material for link
                    const material = new THREE.LineBasicMaterial({
                        color: this.getLinkColor(linkData.type),
                        opacity: 0.7,
                        transparent: true
                    });
                    
                    // Create geometry with positions
                    const geometry = new THREE.BufferGeometry().setFromPoints([
                        sourceNode.position,
                        targetNode.position
                    ]);
                    
                    // Create line
                    const line = new THREE.Line(geometry, material);
                    line.userData = { link: linkData, sourceId, targetId };
                    
                    // Add to scene and store
                    this.scene.add(line);
                    this.links.set(`${sourceId}-${targetId}`, line);
                }
            }
            
            updateLinkPositions() {
                // Update positions of all links (when nodes move)
                this.links.forEach((line, id) => {
                    const { sourceId, targetId } = line.userData;
                    const sourceNode = this.nodes.get(sourceId);
                    const targetNode = this.nodes.get(targetId);
                    
                    if (sourceNode && targetNode) {
                        // Create new geometry with updated positions
                        const points = [
                            sourceNode.position.clone(),
                            targetNode.position.clone()
                        ];
                        line.geometry.setFromPoints(points);
                        line.geometry.attributes.position.needsUpdate = true;
                    }
                });
            }
            
            getNodeSize(nodeType, level) {
                // Base sizes by node type with more gradual scaling
                const sizeByType = {
                    'component_group': 35,    // Root node
                    'component': 30,         // Main components
                    'subcomponent': 25,     // Subcomponents
                    'capability': 22,       // Capabilities
                    'function': 20,         // Functions
                    'specification': 18,    // Specifications
                    'integration': 16,      // Integrations
                    'technique': 15,        // Techniques
                    'application': 14,      // Applications
                    'input': 12,           // Inputs
                    'output': 12           // Outputs
                };

                // Get base size
                let size = sizeByType[nodeType] || 20;
                
                // Scale size based on level, but more gradually
                if (level > 5) {
                    size *= (1 - ((level - 5) * 0.05));
                }
                
                return size;
            }
            
            getNodeColor(nodeType) {
                // Enhanced color scheme for better visibility and hierarchy
                const colors = {
                    'component_group': '#4A90E2',    // Bright blue for root
                    'component': '#50C878',          // Emerald green for main components
                    'subcomponent': '#9B59B6',       // Purple for subcomponents
                    'capability': '#E67E22',         // Orange for capabilities
                    'function': '#E74C3C',           // Red for functions
                    'specification': '#F1C40F',      // Yellow for specifications
                    'integration': '#16A085',        // Turquoise for integrations
                    'technique': '#2ECC71',          // Green for techniques
                    'application': '#3498DB',        // Blue for applications
                    'input': '#95A5A6',             // Gray for inputs
                    'output': '#7F8C8D'             // Darker gray for outputs
                };
                
                return colors[nodeType] || '#808080';
            }
            
            getLinkColor(linkType) {
                // Color map for different link types
                const colors = {
                    'contains': 0xaed6f1,
                    'has_capability': 0xf9e79f,
                    'has_function': 0xd2b4de,
                    'has_specification': 0xabebc6,
                    'has_integration': 0x85c1e9,
                    'has_technique': 0xf5cba7,
                    'has_application': 0xa2d9ce,
                    'has_input': 0xbb8fce,
                    'has_output': 0x7dcea0
                };
                
                return colors[linkType] || 0xbdc3c7;
            }
            
            capitalizeFirstLetter(string) {
                return string.charAt(0).toUpperCase() + string.slice(1);
            }
            
            createHoverDisplay() {
                // Create element for hover text if it doesn't exist
                if (!document.getElementById('hover-node-name')) {
                    const display = document.createElement('div');
                    display.id = 'hover-node-name';
                    display.style.position = 'fixed';
                    display.style.top = '50%';
                    display.style.left = '50%';
                    display.style.transform = 'translate(-50%, -50%)';
                    display.style.zIndex = '9999';
                    display.style.opacity = '0';
                    display.style.pointerEvents = 'none';
                    document.body.appendChild(display);
                    return display;
                }
                return document.getElementById('hover-node-name');
            }
            
            onMouseMove(event) {
                // Calculate mouse position in normalized device coordinates
                const rect = this.container.getBoundingClientRect();
                this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                // Update raycaster
                this.raycaster.setFromCamera(this.mouse, this.camera);
                
                // Check for intersections with nodes
                const intersects = this.raycaster.intersectObjects(Array.from(this.nodes.values()));
                
                // Show/hide hover display
                if (intersects.length > 0) {
                    const node = intersects[0].object.userData.node;
                    this.showHoverText(node.name, node.type);
                } else {
                    this.hideHoverText();
                }
            }
            
            showHoverText(name, type) {
                // Update and show hover text
                this.hoverDisplay.innerHTML = `
                    <div class="node-type">${this.capitalizeFirstLetter(type.replace('_', ' '))}</div>
                    <div class="node-name">${name}</div>
                `;
                this.hoverDisplay.style.opacity = '1';
                
                // Force the hover text to be on top
                document.body.appendChild(this.hoverDisplay);
            }
            
            hideHoverText() {
                // Hide hover text
                if (this.hoverDisplay) {
                    this.hoverDisplay.style.opacity = '0';
                }
            }
            
            async onClick(event) {
                if (!this.graphData || !this.graphData.nodes) {
                    console.error("Graph data not loaded yet");
                    return;
                }

                // Calculate mouse position
                const rect = this.container.getBoundingClientRect();
                this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                // Update raycaster
                this.raycaster.setFromCamera(this.mouse, this.camera);
                
                // Check for intersections with nodes
                const intersects = this.raycaster.intersectObjects(Array.from(this.nodes.values()));
                
                if (intersects.length > 0) {
                    const clickedNode = intersects[0].object;
                    const nodeData = clickedNode.userData.node;
                    
                    console.log(`Clicked on node: ${nodeData.id} (${nodeData.name}) - Type: ${nodeData.type}, Level: ${nodeData.level}`);
                    
                    try {
                        // Special handling for root node
                        if (nodeData.level === 0 || nodeData.id === "ai-alignment") {
                            await this.selectRootNode(nodeData);
                        } else {
                            // Show node details
                            await this.selectNode(nodeData);
                        }
                        
                        // Handle different node types
                        if (nodeData.type === 'application' || nodeData.type === 'input' || 
                            nodeData.type === 'specification' || nodeData.level >= 5 || 
                            nodeData.expandable || nodeData.has_children) {
                            await this.toggleNodeExpansion(nodeData.id);
                        }
                    } catch (error) {
                        console.error(`Error handling click for node ${nodeData.id}: ${error}`);
                    }
                }
            }
            
            async selectNode(nodeData) {
                // Update UI to show selected node details
                const detailsTitle = document.getElementById('details-title');
                const detailsContent = document.getElementById('details-content');
                
                // Set title
                detailsTitle.textContent = nodeData.name;
                
                // Show loading indicator
                detailsContent.innerHTML = `
                    <div class="loading-indicator">
                        <div class="spinner"></div>
                        <span>Loading details...</span>
                    </div>
                `;
                
                try {
                    // Load node details
                    const response = await fetch(`/api/details/${nodeData.id}`);
                    
                    if (!response.ok) {
                        console.error(`Error loading node details: ${response.status} ${response.statusText}`);
                        detailsContent.innerHTML = `
                            <div class="error-message">
                                <h3>Error</h3>
                                <p>Could not load details: ${response.statusText}</p>
                                <p>Status: ${response.status}</p>
                            </div>
                        `;
                        return;
                    }
                    
                    const detailsData = await response.json();
                    
                    if (detailsData.error) {
                        detailsContent.innerHTML = `
                            <div class="error-message">
                                <h3>Error</h3>
                                <p>${detailsData.error}</p>
                            </div>
                        `;
                        return;
                    }
                    
                    this.displayNodeDetails(detailsData);
                    this.updateBreadcrumbs(nodeData.id);
                    
                    // Track selected node
                    this.selectedNode = nodeData;
                } catch (error) {
                    console.error(`Error in selectNode: ${error}`);
                    detailsContent.innerHTML = `
                        <div class="error-message">
                            <h3>Error</h3>
                            <p>An unexpected error occurred: ${error.message}</p>
                        </div>
                    `;
                }
            }
            
            displayNodeDetails(data) {
                const detailsContent = document.getElementById('details-content');
                
                // Clear previous content
                detailsContent.innerHTML = '';
                
                // Add description section
                if (data.description) {
                    const descSection = document.createElement('div');
                    descSection.className = 'detail-section';
                    descSection.innerHTML = `
                        <div class="section-header">
                            <h3>Description</h3>
                            <span class="section-toggle">▼</span>
                        </div>
                        <div class="section-content">
                            <p>${data.description}</p>
                        </div>
                    `;
                    detailsContent.appendChild(descSection);
                }
                
                // Add purpose section if available
                if (data.purpose) {
                    const purposeSection = document.createElement('div');
                    purposeSection.className = 'detail-section';
                    purposeSection.innerHTML = `
                        <div class="section-header">
                            <h3>Purpose</h3>
                            <span class="section-toggle">▼</span>
                        </div>
                        <div class="section-content">
                            <p>${data.purpose}</p>
                        </div>
                    `;
                    detailsContent.appendChild(purposeSection);
                }
                
                // Add special debugging section for specifications and deeper levels
                if (data.type === 'specification' || data.level >= 5) {
                    const debugSection = document.createElement('div');
                    debugSection.className = 'detail-section debug-section';
                    
                    // Find children of this node
                    let childNodes = [];
                    if (this.graphData) {
                        childNodes = this.graphData.nodes.filter(n => n.parent === data.id);
                    }
                    
                    // Also fetch additional data directly from the API
                    const hasIntegration = data.integration !== undefined;
                    
                    // For application nodes, get more details about inputs and outputs
                    let inputOutputInfo = '';
                    if (data.type === 'application') {
                        const inputNodes = childNodes.filter(n => n.type === 'input');
                        let outputCount = 0;
                        
                        // Find related outputs
                        inputNodes.forEach(input => {
                            const outputsForThisInput = this.graphData.nodes.filter(n => 
                                n.parent === input.id && n.type === 'output'
                            );
                            outputCount += outputsForThisInput.length;
                        });
                        
                        inputOutputInfo = `
                            <div class="application-io-info">
                                <p><strong>Inputs:</strong> ${inputNodes.length}</p>
                                <p><strong>Outputs:</strong> ${outputCount} (nested under inputs)</p>
                                <p class="small-note">When you click an application, both inputs and their outputs will be shown</p>
                            </div>
                        `;
                    }
                    
                    debugSection.innerHTML = `
                        <div class="section-header">
                            <h3>Node Details</h3>
                            <span class="section-toggle">▼</span>
                        </div>
                        <div class="section-content">
                            <p><strong>ID:</strong> ${data.id}</p>
                            <p><strong>Type:</strong> ${data.type}</p>
                            <p><strong>Level:</strong> ${data.level}</p>
                            <p><strong>Expandable:</strong> ${data.expandable || false}</p>
                            <p><strong>Has Children:</strong> ${data.has_children || false}</p>
                            <p><strong>Children Count:</strong> ${childNodes.length}</p>
                            ${data.type !== 'application' ? `<p><strong>Has Integration Object:</strong> ${hasIntegration}</p>` : ''}
                            
                            ${inputOutputInfo}
                            
                            ${childNodes.length > 0 ? `
                                <div class="child-nodes">
                                    <p><strong>Children:</strong></p>
                                    <ul>
                                        ${childNodes.map(child => `
                                            <li>
                                                <span class="clickable-item" data-node-id="${child.id}">${child.type} - ${child.name}</span>
                                            </li>
                                        `).join('')}
                                    </ul>
                                </div>
                            ` : ''}
                            
                            ${data.type === 'specification' ? `
                                <div class="force-expand-section">
                                    <button id="force-expand-btn" class="debug-button">Force Show Child Nodes</button>
                                    <p class="small-note">Use if nodes exist in data but aren't showing in visualization</p>
                                </div>
                            ` : ''}
                            
                            ${data.type === 'application' ? `
                                <div class="force-expand-section">
                                    <button id="force-expand-app-btn" class="debug-button">Force Show Inputs & Outputs</button>
                                    <p class="small-note">Force expansion of all inputs and their outputs</p>
                                </div>
                            ` : ''}
                        </div>
                    `;
                    
                    detailsContent.appendChild(debugSection);
                    
                    // Add event listeners after adding to DOM
                    if (data.type === 'specification') {
                        const expandBtn = debugSection.querySelector('#force-expand-btn');
                        if (expandBtn) {
                            expandBtn.addEventListener('click', () => {
                                this.forceExpandChildren(data.id);
                            });
                        }
                    }
                    
                    // Add event listener for application force expand
                    if (data.type === 'application') {
                        const appExpandBtn = debugSection.querySelector('#force-expand-app-btn');
                        if (appExpandBtn) {
                            appExpandBtn.addEventListener('click', () => {
                                this.forceExpandApplication(data.id);
                            });
                        }
                    }
                    
                    // Add click handlers for child nodes
                    debugSection.querySelectorAll('.clickable-item[data-node-id]').forEach(item => {
                        item.addEventListener('click', () => {
                            const nodeId = item.getAttribute('data-node-id');
                            this.navigateToNode(nodeId);
                        });
                    });
                }
                
                // Add components section for component groups
                if (data.components && data.components.length > 0) {
                    const componentsSection = document.createElement('div');
                    componentsSection.className = 'detail-section';
                    
                    let componentsHtml = `
                        <div class="section-header">
                            <h3>Components</h3>
                            <span class="section-toggle">▼</span>
                        </div>
                        <div class="section-content">
                    `;
                    
                    data.components.forEach(component => {
                        componentsHtml += `
                            <div class="clickable-item" data-id="${component.id}">
                                <span class="node-type-badge component">Component</span>
                                <strong>${component.name}</strong>
                                ${component.description ? 
                                    `<div class="item-description">${component.description}</div>` : ''}
                            </div>
                        `;
                    });
                    
                    componentsHtml += `</div>`;
                    componentsSection.innerHTML = componentsHtml;
                    detailsContent.appendChild(componentsSection);
                    
                    // Add click handlers for components
                    componentsSection.querySelectorAll('.clickable-item').forEach(item => {
                        item.addEventListener('click', () => {
                            const id = item.getAttribute('data-id');
                            // Find the node in our data
                            const node = this.graphData.nodes.find(n => n.id === id);
                            if (node) {
                                this.selectNode(node);
                                this.toggleNodeExpansion(id);
                            }
                        });
                    });
                }
                
                // Add capabilities section for subcomponents
                if (data.capabilities && data.capabilities.length > 0) {
                    const capabilitiesSection = document.createElement('div');
                    capabilitiesSection.className = 'detail-section';
                    
                    let capabilitiesHtml = `
                        <div class="section-header">
                            <h3>Capabilities</h3>
                            <span class="section-toggle">▼</span>
                        </div>
                        <div class="section-content">
                    `;
                    
                    data.capabilities.forEach(capability => {
                        if (typeof capability === 'object' && capability.name) {
                            capabilitiesHtml += `
                                <div class="clickable-item" data-id="${data.id}-capability-${capability.name.toLowerCase().replace(/\s+/g, '-')}">
                                    <span class="node-type-badge capability">Capability</span>
                                    <strong>${capability.name}</strong>
                                    ${capability.description ? 
                                        `<div class="item-description">${capability.description}</div>` : ''}
                                </div>
                            `;
                        }
                    });
                    
                    capabilitiesHtml += `</div>`;
                    capabilitiesSection.innerHTML = capabilitiesHtml;
                    detailsContent.appendChild(capabilitiesSection);
                }
                
                // Add additional dynamic content based on node type
                // This would be expanded with more sections as needed
                
                // Setup section toggles
                this.setupSectionToggles();
            }
            
            setupSectionToggles() {
                // Add event listeners to section toggle buttons
                document.querySelectorAll('.section-toggle').forEach(toggle => {
                    if (!toggle.hasAttribute('data-initialized')) {
                        toggle.addEventListener('click', (e) => {
                            const content = e.target.closest('.section-header').nextElementSibling;
                            const isCollapsed = toggle.classList.contains('collapsed');
                            
                            if (isCollapsed) {
                                content.style.display = 'block';
                                toggle.classList.remove('collapsed');
                                toggle.textContent = '▼';
                            } else {
                                content.style.display = 'none';
                                toggle.classList.add('collapsed');
                                toggle.textContent = '▶';
                            }
                        });
                        
                        toggle.setAttribute('data-initialized', 'true');
                    }
                });
            }
            
            updateBreadcrumbs(nodeId) {
                const breadcrumbContainer = document.getElementById('breadcrumb-navigation');
                breadcrumbContainer.innerHTML = '';
                
                // Fetch hierarchy path
                fetch(`/api/hierarchy-path/${nodeId}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.path && data.path.length > 0) {
                            data.path.forEach((item, index) => {
                                const isLast = index === data.path.length - 1;
                                
                                const breadcrumbItem = document.createElement('div');
                                breadcrumbItem.className = 'breadcrumb-item' + (isLast ? '' : ' clickable');
                                breadcrumbItem.textContent = item.name;
                                
                                if (!isLast) {
                                    // Add separator
                                    breadcrumbItem.innerHTML += '<span class="breadcrumb-separator">›</span>';
                                    
                                    // Make clickable
                                    breadcrumbItem.addEventListener('click', () => {
                                        // Find node in graph data
                                        const node = this.graphData.nodes.find(n => n.id === item.id);
                                        if (node) {
                                            this.selectNode(node);
                                        }
                                    });
                                }
                                
                                breadcrumbContainer.appendChild(breadcrumbItem);
                            });
                        }
                    })
                    .catch(error => {
                        console.error('Error loading breadcrumbs:', error);
                    });
            }
            
            async toggleNodeExpansion(nodeId) {
                console.log(`Toggling expansion for node: ${nodeId}`);
                
                // Either expand or collapse based on current state
                if (this.expandedNodes.has(nodeId)) {
                    console.log(`Node was expanded, collapsing: ${nodeId}`);
                    this.collapseNode(nodeId);
                } else {
                    console.log(`Node was collapsed, expanding: ${nodeId}`);
                    await this.expandNode(nodeId);
                }
                
                // Log expanded nodes for debugging
                console.log(`Current expanded nodes: ${Array.from(this.expandedNodes).join(', ')}`);
            }
            
            async expandNode(nodeId) {
                if (!this.graphData || !this.graphData.nodes) {
                    console.error("Graph data not loaded yet");
                    return;
                }

                const node = this.graphData.nodes.find(n => n.id === nodeId);
                if (!node) {
                    console.error(`Node not found: ${nodeId}`);
                    return;
                }
                
                console.log(`Expanding node: ${node.id} (${node.type})`);
                
                try {
                    // Add node to expanded set
                    this.expandedNodes.add(nodeId);
                    
                    // Handle different node types
                    if (node.type === 'subcomponent') {
                        // Check if we need to add capability nodes
                        const backendData = await this.findNodeInBackendData(nodeId);
                        if (backendData && backendData.capabilities) {
                            backendData.capabilities.forEach(capability => {
                                if (typeof capability === 'object' && capability.id) {
                                    // Add capability node if it doesn't exist
                                    if (!this.graphData.nodes.some(n => n.id === capability.id)) {
                                        const capabilityNode = {
                                            id: capability.id,
                                            name: capability.name,
                                            type: 'capability',
                                            description: capability.description,
                                            parent: nodeId,
                                            level: node.level + 1,
                                            expandable: true,
                                            has_children: true
                                        };
                                        this.graphData.nodes.push(capabilityNode);
                                        
                                        // Add link
                                        this.graphData.links.push({
                                            source: nodeId,
                                            target: capability.id,
                                            type: 'has_capability'
                                        });

                                        // Add functions for this capability
                                        if (capability.functions) {
                                            capability.functions.forEach(func => {
                                                if (!this.graphData.nodes.some(n => n.id === func.id)) {
                                                    const functionNode = {
                                                        id: func.id,
                                                        name: func.name,
                                                        type: 'function',
                                                        description: func.description,
                                                        parent: capability.id,
                                                        level: node.level + 2,
                                                        expandable: func.specifications && func.specifications.length > 0,
                                                        has_children: func.specifications && func.specifications.length > 0
                                                    };
                                                    this.graphData.nodes.push(functionNode);
                                                    
                                                    // Add link
                                                    this.graphData.links.push({
                                                        source: capability.id,
                                                        target: func.id,
                                                        type: 'has_function'
                                                    });
                                                }
                                            });
                                        }
                                    }
                                }
                            });
                        }
                    } else if (node.type === 'capability') {
                        // Find and add function nodes
                        const backendData = await this.findNodeInBackendData(nodeId);
                        if (backendData && backendData.functions) {
                            backendData.functions.forEach(func => {
                                if (!this.graphData.nodes.some(n => n.id === func.id)) {
                                    const functionNode = {
                                        id: func.id,
                                        name: func.name,
                                        type: 'function',
                                        description: func.description,
                                        parent: nodeId,
                                        level: node.level + 1,
                                        expandable: func.specifications && func.specifications.length > 0,
                                        has_children: func.specifications && func.specifications.length > 0
                                    };
                                    this.graphData.nodes.push(functionNode);
                                    
                                    // Add link
                                    this.graphData.links.push({
                                        source: nodeId,
                                        target: func.id,
                                        type: 'has_function'
                                    });
                                }
                            });
                        }
                    } else if (node.type === 'function') {
                        // Find and add specification nodes
                        const backendData = await this.findNodeInBackendData(nodeId);
                        if (backendData && backendData.specifications) {
                            backendData.specifications.forEach(spec => {
                                if (!this.graphData.nodes.some(n => n.id === spec.id)) {
                                    const specNode = {
                                        id: spec.id,
                                        name: spec.name,
                                        type: 'specification',
                                        description: spec.description,
                                        parent: nodeId,
                                        level: node.level + 1,
                                        expandable: spec.integration !== undefined,
                                        has_children: spec.integration !== undefined
                                    };
                                    this.graphData.nodes.push(specNode);
                                    
                                    // Add link
                                    this.graphData.links.push({
                                        source: nodeId,
                                        target: spec.id,
                                        type: 'has_specification'
                                    });
                                }
                            });
                        }
                    } else if (node.type === 'specification') {
                        // Find and add integration node
                        const backendData = await this.findNodeInBackendData(nodeId);
                        if (backendData && backendData.integration) {
                            const integration = backendData.integration;
                            if (!this.graphData.nodes.some(n => n.id === integration.id)) {
                                const integrationNode = {
                                    id: integration.id,
                                    name: integration.name,
                                    type: 'integration',
                                    description: integration.description,
                                    parent: nodeId,
                                    level: node.level + 1,
                                    expandable: integration.techniques && integration.techniques.length > 0,
                                    has_children: integration.techniques && integration.techniques.length > 0
                                };
                                this.graphData.nodes.push(integrationNode);
                                
                                // Add link
                                this.graphData.links.push({
                                    source: nodeId,
                                    target: integration.id,
                                    type: 'has_integration'
                                });
                            }
                        }
                    } else if (node.type === 'integration') {
                        // Find and add technique nodes
                        const backendData = await this.findNodeInBackendData(nodeId);
                        if (backendData && backendData.techniques) {
                            backendData.techniques.forEach(technique => {
                                if (!this.graphData.nodes.some(n => n.id === technique.id)) {
                                    const techniqueNode = {
                                        id: technique.id,
                                        name: technique.name,
                                        type: 'technique',
                                        description: technique.description,
                                        parent: nodeId,
                                        level: node.level + 1,
                                        expandable: technique.applications && technique.applications.length > 0,
                                        has_children: technique.applications && technique.applications.length > 0
                                    };
                                    this.graphData.nodes.push(techniqueNode);
                                    
                                    // Add link
                                    this.graphData.links.push({
                                        source: nodeId,
                                        target: technique.id,
                                        type: 'has_technique'
                                    });
                                }
                            });
                        }
                    } else if (node.type === 'technique') {
                        // Find and add application nodes
                        const backendData = await this.findNodeInBackendData(nodeId);
                        if (backendData && backendData.applications) {
                            backendData.applications.forEach(app => {
                                if (!this.graphData.nodes.some(n => n.id === app.id)) {
                                    const applicationNode = {
                                        id: app.id,
                                        name: app.name,
                                        type: 'application',
                                        description: app.description,
                                        parent: nodeId,
                                        level: node.level + 1,
                                        expandable: (app.inputs && app.inputs.length > 0) || (app.outputs && app.outputs.length > 0),
                                        has_children: (app.inputs && app.inputs.length > 0) || (app.outputs && app.outputs.length > 0)
                                    };
                                    this.graphData.nodes.push(applicationNode);
                                    
                                    // Add link
                                    this.graphData.links.push({
                                        source: nodeId,
                                        target: app.id,
                                        type: 'has_application'
                                    });
                                }
                            });
                        }
                    } else if (node.type === 'application') {
                        // When expanding an application, fetch both inputs and outputs
                        const backendData = await this.findNodeInBackendData(nodeId);
                        if (backendData) {
                            // Handle inputs directly attached to the application
                            const inputs = backendData.inputs || [];
                            inputs.forEach(input => {
                                if (!this.graphData.nodes.some(n => n.id === input.id)) {
                                    const inputNode = {
                                        id: input.id,
                                        name: input.name,
                                        type: 'input',
                                        description: input.description,
                                        parent: nodeId,
                                        level: node.level + 1,
                                        expandable: false,
                                        has_children: false
                                    };
                                    this.graphData.nodes.push(inputNode);
                                    
                                    // Add link from application to input
                                    this.graphData.links.push({
                                        source: nodeId,
                                        target: input.id,
                                        type: 'has_input'
                                    });
                                }
                            });
                            
                            // Handle outputs directly attached to the application
                            const outputs = backendData.outputs || [];
                            let allOutputs = [...outputs];
                            
                            // Also extract outputs that might be nested in inputs
                            inputs.forEach(input => {
                                if (input.outputs && Array.isArray(input.outputs)) {
                                    allOutputs = [...allOutputs, ...input.outputs];
                                }
                            });
                            
                            // Add output nodes
                            allOutputs.forEach(output => {
                                if (!this.graphData.nodes.some(n => n.id === output.id)) {
                                    const outputNode = {
                                        id: output.id,
                                        name: output.name,
                                        type: 'output',
                                        description: output.description,
                                        parent: nodeId, // Parent is the application
                                        level: node.level + 1, // Same level as inputs
                                        expandable: false,
                                        has_children: false
                                    };
                                    this.graphData.nodes.push(outputNode);
                                    
                                    // Add link from application to output
                                    this.graphData.links.push({
                                        source: nodeId,
                                        target: output.id,
                                        type: 'has_output'
                                    });
                                }
                            });
                        }
                    }
                    
                    // Update visible nodes and redraw
                    const visibleNodes = this.getVisibleNodes();
                    this.positionNodes(visibleNodes);
                    this.createNodeObjects(visibleNodes);
                    this.createLinkObjects(this.getVisibleLinks(visibleNodes));
                } catch (error) {
                    console.error(`Error expanding node ${nodeId}: ${error}`);
                    this.expandedNodes.delete(nodeId); // Rollback expansion on error
                }
            }
            
            collapseNode(nodeId) {
                if (!this.graphData || !this.graphData.nodes) {
                    console.error("Graph data not loaded yet");
                    return;
                }

                const node = this.graphData.nodes.find(n => n.id === nodeId);
                if (!node) {
                    console.error(`Node not found: ${nodeId}`);
                    return;
                }
                
                // Remove node from expanded set
                this.expandedNodes.delete(nodeId);
                
                // Special handling for applications
                if (node.type === 'application') {
                    // When collapsing an application, also collapse its inputs and outputs
                    const inputs = this.graphData.nodes.filter(n => 
                        n.type === 'input' && 
                        n.parent === nodeId
                    );
                    inputs.forEach(input => this.expandedNodes.delete(input.id));
                    
                    // Also collapse direct outputs of the application
                    const outputs = this.graphData.nodes.filter(n =>
                        n.type === 'output' &&
                        n.parent === nodeId
                    );
                    outputs.forEach(output => this.expandedNodes.delete(output.id));
                }
                
                // Recursively collapse all descendant nodes
                this.recursivelyCollapseChildren(nodeId);
                
                // Update visible nodes and redraw
                const visibleNodes = this.getVisibleNodes();
                this.positionNodes(visibleNodes);
                this.createNodeObjects(visibleNodes);
                this.createLinkObjects(this.getVisibleLinks(visibleNodes));
            }
            
            onWindowResize() {
                // Update camera aspect ratio
                this.camera.aspect = this.container.clientWidth / this.container.clientHeight;
                this.camera.updateProjectionMatrix();
                
                // Update renderer size
                this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Update controls
                this.controls.update();
                
                const deltaTime = this.clock.getDelta();
                const time = Date.now() * 0.001;
                
                if (this.isRotating) {
                    // Rotate root node around its axis
                    const rootNode = Array.from(this.nodes.values()).find(node => !node.userData.node.parent);
                    if (rootNode) {
                        rootNode.rotation.y += deltaTime * 0.2;
                    }
                    
                    // Animate other nodes
                    this.nodes.forEach((nodeMesh, nodeId) => {
                        const nodeData = nodeMesh.userData.node;
                        if (!nodeData.parent) return;
                        
                        const basePos = this.nodePositions.get(nodeId);
                        if (!basePos) return;
                        
                        // Calculate orbital parameters
                        const level = nodeData.level;
                        const orbitSpeed = 0.1 * Math.pow(0.85, level - 1); // Slower for outer levels
                        const wobbleAmount = Math.min(0.1, level * 0.01);
                        
                        // Calculate orbital motion
                        const radius = Math.sqrt(basePos.x * basePos.x + basePos.z * basePos.z);
                        const currentAngle = Math.atan2(nodeMesh.position.z - basePos.z, nodeMesh.position.x - basePos.x);
                        const newAngle = currentAngle + orbitSpeed * deltaTime;
                        
                        // Add wobble effect
                        const wobbleX = Math.sin(time * 1.1 + level) * wobbleAmount * radius;
                        const wobbleY = Math.sin(time * 0.7 + level) * wobbleAmount * radius;
                        const wobbleZ = Math.sin(time * 0.9 + level) * wobbleAmount * radius;
                        
                        // Update position with smooth transition
                        nodeMesh.position.x = basePos.x + radius * Math.cos(newAngle) + wobbleX;
                        nodeMesh.position.y = basePos.y + wobbleY;
                        nodeMesh.position.z = basePos.z + radius * Math.sin(newAngle) + wobbleZ;
                        
                        // Add node rotation
                        nodeMesh.rotation.y += deltaTime * orbitSpeed * 0.5;
                        nodeMesh.rotation.x = Math.sin(time * 0.5) * wobbleAmount * 0.2;
                    });
                    
                    // Update link positions
                    this.updateLinkPositions();
                }
                
                // Render scene
                this.renderer.render(this.scene, this.camera);
                
                // Update TWEEN animations
                if (TWEEN) {
                    TWEEN.update();
                }
            }
            
            // Control functions
            zoomIn() {
                const targetZ = this.camera.position.z * 0.8;
                new TWEEN.Tween(this.camera.position)
                    .to({ z: targetZ }, 300)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();
            }
            
            zoomOut() {
                const targetZ = this.camera.position.z * 1.2;
                new TWEEN.Tween(this.camera.position)
                    .to({ z: targetZ }, 300)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();
            }
            
            resetView() {
                new TWEEN.Tween(this.camera.position)
                    .to({ x: 0, y: 0, z: 500 }, 500)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();
                    
                new TWEEN.Tween(this.scene.rotation)
                    .to({ x: 0, y: 0, z: 0 }, 500)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();
                    
                this.controls.reset();
            }
            
            toggleRotation() {
                this.isRotating = !this.isRotating;
            }
            
            // Add new method to force expanding children for a given specification node
            forceExpandChildren(specificationId) {
                console.log(`Force expanding children for specification: ${specificationId}`);
                
                // Get the specification details directly from the backend
                const specData = this.findNodeInBackendData(specificationId);
                
                if (!specData) {
                    console.error(`Could not find specification data for: ${specificationId}`);
                    alert('Could not load specification details');
                    return;
                }
                
                console.log('Specification data:', specData);
                
                // Check if the specification has an integration
                if (specData.integration) {
                    const integrationData = specData.integration;
                    console.log('Found integration:', integrationData);
                    
                    // Create integration node if it doesn't exist
                    const integrationId = integrationData.id;
                    const integrationExists = this.graphData.nodes.some(n => n.id === integrationId);
                    
                    if (!integrationExists) {
                        console.log(`Adding missing integration node: ${integrationId}`);
                        
                        // Add the integration node
                        const newIntegrationNode = {
                            id: integrationId,
                            name: integrationData.name,
                            type: 'integration',
                            description: integrationData.description,
                            parent: specificationId,
                            level: 6,
                            expandable: integrationData.techniques && integrationData.techniques.length > 0,
                            has_children: integrationData.techniques && integrationData.techniques.length > 0
                        };
                        
                        // Add the node to the graph data
                        this.graphData.nodes.push(newIntegrationNode);
                        
                        // Add link from specification to integration
                        this.graphData.links.push({
                            source: specificationId,
                            target: integrationId,
                            type: 'has_integration'
                        });
                        
                        // Now check for techniques and add them
                        if (integrationData.techniques && integrationData.techniques.length > 0) {
                            integrationData.techniques.forEach(technique => {
                                const techniqueId = technique.id;
                                const techniqueExists = this.graphData.nodes.some(n => n.id === techniqueId);
                                
                                if (!techniqueExists) {
                                    console.log(`Adding missing technique node: ${techniqueId}`);
                                    
                                    // Add the technique node
                                    const newTechniqueNode = {
                                        id: techniqueId,
                                        name: technique.name,
                                        type: 'technique',
                                        description: technique.description,
                                        parent: integrationId,
                                        level: 7,
                                        expandable: technique.applications && technique.applications.length > 0,
                                        has_children: technique.applications && technique.applications.length > 0
                                    };
                                    
                                    // Add the node to the graph data
                                    this.graphData.nodes.push(newTechniqueNode);
                                    
                                    // Add link from integration to technique
                                    this.graphData.links.push({
                                        source: integrationId,
                                        target: techniqueId,
                                        type: 'has_technique'
                                    });
                                }
                            });
                        }
                    }
                    
                    // Mark the specification as expanded
                    this.expandedNodes.add(specificationId);
                    
                    // Ensure the integration is expanded
                    if (integrationId) {
                        this.expandedNodes.add(integrationId);
                    }
                    
                    // Update the visualization
                    const visibleNodes = this.getVisibleNodes();
                    const visibleLinks = this.getVisibleLinks(visibleNodes);
                    
                    console.log(`After force expansion: ${visibleNodes.length} nodes visible`);
                    
                    // Position all nodes
                    this.positionNodes(visibleNodes);
                    
                    // Update visual elements
                    this.createNodeObjects(visibleNodes);
                    this.createLinkObjects(visibleLinks);
                    
                    // Refresh the node details display
                    this.selectNode(this.selectedNode);
                } else {
                    console.warn('No integration found in this specification');
                    alert('No integration found in this specification');
                }
            }
            
            // Method to force expand an application node with all its inputs and outputs
            forceExpandApplication(applicationId) {
                console.log(`Force expanding application with all inputs and outputs: ${applicationId}`);
                
                // Get the application details
                const appNodeData = this.graphData.nodes.find(node => node.id === applicationId);
                if (!appNodeData) {
                    console.error(`Could not find application data for: ${applicationId}`);
                    return;
                }
                
                // Mark application as expanded
                this.expandedNodes.add(applicationId);
                
                // Get backend application data to ensure we have all inputs
                const appData = this.findNodeInBackendData(applicationId);
                
                // Get all inputs currently in the graph
                const inputNodes = this.graphData.nodes.filter(node => 
                    node.parent === applicationId && node.type === 'input'
                );
                
                console.log(`Found ${inputNodes.length} input nodes for application: ${appNodeData.name}`);
                
                // Mark all inputs as expanded to show outputs
                inputNodes.forEach(input => {
                    this.expandedNodes.add(input.id);
                    
                    // Look for outputs of this input
                    const outputNodes = this.graphData.nodes.filter(node => 
                        node.parent === input.id && node.type === 'output'
                    );
                    
                    console.log(`Found ${outputNodes.length} output nodes for input: ${input.name}`);
                });
                
                // Add missing inputs and outputs from backend data if available
                if (appData && appData.inputs) {
                    const backendInputs = Array.isArray(appData.inputs) ? appData.inputs : [appData.inputs];
                    
                    // Check if we need to create missing input nodes
                    backendInputs.forEach(inputData => {
                        if (typeof inputData !== 'object') return;
                        
                        const inputName = inputData.name || (typeof inputData === 'string' ? inputData : 'Input');
                        const inputId = inputData.id || `${applicationId}-input-${inputName.toLowerCase().replace(/\s+/g, '-')}`;
                        
                        // Check if input already exists in graph data
                        const inputExists = this.graphData.nodes.some(n => n.id === inputId);
                        
                        if (!inputExists) {
                            console.log(`Adding missing input node: ${inputId}`);
                            
                            // Create input node
                            const newInputNode = {
                                id: inputId,
                                name: inputName,
                                type: 'input',
                                description: inputData.description || '',
                                parent: applicationId,
                                level: 9,
                                expandable: inputData.outputs && inputData.outputs.length > 0,
                                has_children: inputData.outputs && inputData.outputs.length > 0
                            };
                            
                            // Add to graph data
                            this.graphData.nodes.push(newInputNode);
                            
                            // Add link
                            this.graphData.links.push({
                                source: applicationId,
                                target: inputId,
                                type: 'has_input'
                            });
                            
                            // Mark as expanded
                            this.expandedNodes.add(inputId);
                            
                            // Add outputs if available
                            if (inputData.outputs) {
                                const outputs = Array.isArray(inputData.outputs) ? inputData.outputs : [inputData.outputs];
                                
                                outputs.forEach(outputData => {
                                    if (typeof outputData !== 'object') return;
                                    
                                    const outputName = outputData.name || (typeof outputData === 'string' ? outputData : 'Output');
                                    const outputId = outputData.id || `${inputId}-output-${outputName.toLowerCase().replace(/\s+/g, '-')}`;
                                    
                                    // Check if output already exists
                                    const outputExists = this.graphData.nodes.some(n => n.id === outputId);
                                    
                                    if (!outputExists) {
                                        console.log(`Adding missing output node: ${outputId}`);
                                        
                                        // Create output node
                                        const newOutputNode = {
                                            id: outputId,
                                            name: outputName,
                                            type: 'output',
                                            description: outputData.description || '',
                                            parent: inputId,
                                            level: 10,
                                            expandable: false,
                                            has_children: false
                                        };
                                        
                                        // Add to graph data
                                        this.graphData.nodes.push(newOutputNode);
                                        
                                        // Add link
                                        this.graphData.links.push({
                                            source: inputId,
                                            target: outputId,
                                            type: 'has_output'
                                        });
                                    }
                                });
                            }
                        }
                    });
                }
                
                // Update visualization
                const visibleNodes = this.getVisibleNodes();
                const visibleLinks = this.getVisibleLinks(visibleNodes);
                
                console.log(`After force expansion: ${visibleNodes.length} nodes visible, ${visibleLinks.length} links visible`);
                
                // Position nodes
                this.positionNodes(visibleNodes);
                
                // Update visual elements
                this.createNodeObjects(visibleNodes);
                this.createLinkObjects(visibleLinks);
                
                // Refresh node details display
                this.selectNode(this.selectedNode);
            }
            
            // Helper method to expand an input node and ensure its outputs are visible
            expandInputWithOutputs(inputId) {
                console.log(`Expanding input with outputs: ${inputId}`);
                
                // Mark the input as expanded
                this.expandedNodes.add(inputId);
                
                // Find output nodes
                const outputNodes = this.graphData.nodes.filter(node => 
                    node.parent === inputId && node.type === 'output'
                );
                
                console.log(`Found ${outputNodes.length} output nodes for input: ${inputId}`);
                
                // Get all visible nodes and update the visualization
                const visibleNodes = this.getVisibleNodes();
                const visibleLinks = this.getVisibleLinks(visibleNodes);
                
                console.log(`After expanding input with outputs: ${visibleNodes.length} nodes visible`);
                
                // Position all nodes
                this.positionNodes(visibleNodes);
                
                // Update visual elements
                this.createNodeObjects(visibleNodes);
                this.createLinkObjects(visibleLinks);
            }
            
            // Add helper method to find node data in backend data
            async findNodeInBackendData(nodeId) {
                if (!nodeId) return null;
                
                // First check if it's a direct node in graphData
                const node = this.graphData.nodes.find(n => n.id === nodeId);
                if (!node) return null;
                
                try {
                    // Special handling for root node
                    if (nodeId === "ai-alignment" || node.level === 0) {
                        console.log("Using root endpoint for node data");
                        const response = await fetch('/api/root');
                        
                        if (!response.ok) {
                            console.error(`Error fetching root data: ${response.status} ${response.statusText}`);
                            return null;
                        }
                        
                        const data = await response.json();
                        console.log("Successfully fetched root data:", data);
                        return data;
                    }
                    
                    // For all other node types, fetch the complete data from the backend
                    console.log(`Fetching complete data for node: ${nodeId}`);
                    const response = await fetch(`/api/details/${nodeId}`);
                    
                    if (!response.ok) {
                        console.error(`Error fetching node data: ${response.status} ${response.statusText}`);
                        return null;
                    }
                    
                    const data = await response.json();
                    console.log(`Successfully fetched data for ${nodeId}:`, data);
                    return data;
                } catch (error) {
                    console.error(`Error fetching node data: ${error}`);
                    return null;
                }
            }
            
            // New method to specifically select the root node using a dedicated endpoint
            async selectRootNode(rootNode) {
                // Update UI to show selected node details
                const detailsTitle = document.getElementById('details-title');
                const detailsContent = document.getElementById('details-content');
                
                // Set title
                detailsTitle.textContent = rootNode.name;
                
                // Show loading indicator
                detailsContent.innerHTML = `
                    <div class="loading-indicator">
                        <div class="spinner"></div>
                        <span>Loading details...</span>
                    </div>
                `;
                
                try {
                    // Use the dedicated root endpoint
                    console.log("Fetching root node details from dedicated endpoint");
                    const response = await fetch('/api/root');
                    
                    if (!response.ok) {
                        console.error(`Error loading root details: ${response.status} ${response.statusText}`);
                        detailsContent.innerHTML = `
                            <div class="error-message">
                                <h3>Error</h3>
                                <p>Could not load root details: ${response.statusText}</p>
                                <p>Status: ${response.status}</p>
                            </div>
                        `;
                        return;
                    }
                    
                    const detailsData = await response.json();
                    
                    if (detailsData.error) {
                        detailsContent.innerHTML = `
                            <div class="error-message">
                                <h3>Error</h3>
                                <p>${detailsData.error}</p>
                            </div>
                        `;
                        return;
                    }
                    
                    this.displayNodeDetails(detailsData);
                    this.updateBreadcrumbs(rootNode.id);
                    
                    // Track selected node
                    this.selectedNode = rootNode;
                } catch (error) {
                    console.error(`Error in selectRootNode: ${error}`);
                    detailsContent.innerHTML = `
                        <div class="error-message">
                            <h3>Error</h3>
                            <p>An unexpected error occurred: ${error.message}</p>
                        </div>
                    `;
                }
            }
            
            recursivelyCollapseChildren(nodeId) {
                // Find all direct children
                const children = this.graphData.nodes.filter(n => n.parent === nodeId);
                
                // Collapse each child and its descendants
                children.forEach(child => {
                    // Remove from expanded set
                    this.expandedNodes.delete(child.id);
                    
                    // Recursively collapse descendants
                    this.recursivelyCollapseChildren(child.id);
                });
            }
        }
        
        // Initialize visualization when page loads
        window.addEventListener('DOMContentLoaded', () => {
            const visualization = new AIAlignmentVisualization();
        });
    </script>
</body>
</html> 