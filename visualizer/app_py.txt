from flask import Flask, render_template, jsonify, url_for
import json
import os
import glob
import logging
from logging.handlers import RotatingFileHandler

app = Flask(__name__, static_url_path='/static', static_folder='static')

# Configure logging
if not os.path.exists('logs'):
    os.mkdir('logs')
file_handler = RotatingFileHandler('logs/app.log', maxBytes=10240, backupCount=10)
file_handler.setFormatter(logging.Formatter(
    '%(asctime)s %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]'
))
file_handler.setLevel(logging.INFO)
app.logger.addHandler(file_handler)
app.logger.setLevel(logging.INFO)
app.logger.info('AI Alignment Visualization startup')

# Path to AI alignment files
AI_ALIGNMENT_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))  # Absolute path to parent directory
COMPONENTS_DIR = os.path.join(AI_ALIGNMENT_DIR, "components")
SUBCOMPONENTS_DIR = os.path.join(AI_ALIGNMENT_DIR, "subcomponents")
LITERATURE_FILE = os.path.join(AI_ALIGNMENT_DIR, "ai-alignment.json")

def load_json_file(file_path):
    """Load and parse a JSON file."""
    try:
        app.logger.info(f"Attempting to load file from {file_path}")
        normalized_path = os.path.normpath(file_path)
        app.logger.info(f"Normalized path: {normalized_path}")
        if not os.path.exists(normalized_path):
            app.logger.error(f"File does not exist: {normalized_path}")
            return None
        with open(normalized_path, 'r', encoding='utf-8') as f:
            return json.load(f)
    except Exception as e:
        app.logger.error(f"Error loading {file_path}: {e}")
        return None

def get_literature_data():
    """Load literature data from the literature JSON file."""
    if os.path.exists(LITERATURE_FILE):
        literature = load_json_file(LITERATURE_FILE)
        if literature:
            return literature
    app.logger.warning(f"Literature file not found at {LITERATURE_FILE}")
    return {}

def get_component_data():
    """Load component data from the ai-alignment directory."""
    # Load the component group data (index file)
    component_group_path = os.path.join(AI_ALIGNMENT_DIR, "ai-alignment.json")
    app.logger.info(f"Looking for component group at {component_group_path}")
    
    # Default component group data if not found
    component_group = {
        "id": "ai-alignment",
        "name": "AI Alignment",
        "description": "Methods to ensure AI systems remain aligned with human values and intentions.",
        "type": "component_group",
        "components": [
            {
                "id": "technical-safeguards",
                "name": "Technical Safeguards",
                "description": "Engineering approaches to ensure AI systems behave as intended and remain within safe operational boundaries"
            },
            {
                "id": "value-learning",
                "name": "Value Learning",
                "description": "Systems that enable AI to learn and internalize human values through observation and feedback"
            },
            {
                "id": "interpretability-tools",
                "name": "Interpretability Tools",
                "description": "Methods to understand AI reasoning and decision-making processes"
            },
            {
                "id": "oversight-mechanisms",
                "name": "Oversight Mechanisms",
                "description": "Systems for monitoring and evaluating AI behavior and alignment"
            },
            {
                "id": "democratic-alignment",
                "name": "Democratic Alignment",
                "description": "Frameworks for democratic direction and control of AI systems"
            }
        ]
    }
    
    if os.path.exists(component_group_path):
        loaded_data = load_json_file(component_group_path)
        if loaded_data:
            component_group = loaded_data
    else:
        app.logger.warning(f"Component group file not found at {component_group_path}, using default data")
    
    # Load individual component files or extract from default data
    components = {}
    
    # Check if components directory exists
    if os.path.exists(COMPONENTS_DIR):
        app.logger.info(f"Looking for component files in {COMPONENTS_DIR}")
        component_files = glob.glob(os.path.join(COMPONENTS_DIR, "*.json"))
        app.logger.info(f"Found {len(component_files)} component files")
        
        for file_path in component_files:
            component_data = load_json_file(file_path)
            if component_data:
                component_id = os.path.basename(file_path).replace(".json", "")
                components[component_id] = component_data
    else:
        app.logger.warning(f"Components directory not found at {COMPONENTS_DIR}, using components from default data")
        # Use components from the default data
        if "components" in component_group and isinstance(component_group["components"], list):
            for component in component_group["components"]:
                if "id" in component:
                    components[component["id"]] = component
    
    return {
        "component_group": component_group,
        "components": components
    }

def get_subcomponent_data():
    """Load subcomponent data from the subcomponents directory."""
    subcomponents = {}
    
    if not os.path.exists(SUBCOMPONENTS_DIR):
        app.logger.warning(f"Subcomponents directory not found at {SUBCOMPONENTS_DIR}")
        return subcomponents
    
    app.logger.info(f"Looking for subcomponent files in {SUBCOMPONENTS_DIR}")
    subcomponent_files = glob.glob(os.path.join(SUBCOMPONENTS_DIR, "*.json"))
    app.logger.info(f"Found {len(subcomponent_files)} subcomponent files")
    
    for file_path in glob.glob(os.path.join(SUBCOMPONENTS_DIR, "*.json")):
        try:
            data = load_json_file(file_path)
            if data:
                subcomponent_id = os.path.basename(file_path).replace(".json", "")
                # Ensure the subcomponent has an ID (either set or from filename)
                if "id" not in data:
                    data["id"] = subcomponent_id
                subcomponents[subcomponent_id] = data
        except Exception as e:
            app.logger.error(f"Error processing {file_path}: {e}")
    
    return subcomponents

def get_node_by_id(node_id):
    """Find a node by its ID across all data sources."""
    # Check in component group
    component_data = get_component_data()
    if node_id == component_data["component_group"]["id"]:
        return component_data["component_group"]
    
    # Check in components
    if node_id in component_data["components"]:
        return component_data["components"][node_id]
    
    # Check in subcomponents
    subcomponent_data = get_subcomponent_data()
    if node_id in subcomponent_data:
        return subcomponent_data[node_id]
    
    # Check in built graph data for other node types
    graph_data = build_graph_data()
    for node in graph_data["nodes"]:
        if node["id"] == node_id:
            return node
    
    app.logger.warning(f"Node not found: {node_id}")
    return None

def build_graph_data():
    """Build a complete hierarchical graph structure from component files."""
    component_data = get_component_data()
    subcomponent_data = get_subcomponent_data()
    
    # Create nodes for component group
    nodes = [{
        "id": component_data["component_group"]["id"],
        "name": component_data["component_group"]["name"],
        "type": "component_group",
        "description": component_data["component_group"]["description"],
        "level": 0,
        "expandable": True,
        "has_children": len(component_data["components"]) > 0
    }]
    
    # Create links list
    links = []
    
    # Process components according to their specific structure
    for component_id, component in component_data["components"].items():
        # Count subcomponents for this component
        component_subcomponents = [s for s_id, s in subcomponent_data.items() 
                                 if "parent" in s and s["parent"] == component_id]
        has_subcomponents = len(component_subcomponents) > 0
        
        # Create component node
        nodes.append({
            "id": component_id,
            "name": component["name"],
            "type": "component",
            "description": component["description"],
            "parent": component_data["component_group"]["id"],
            "level": 1,
            "expandable": has_subcomponents,
            "has_children": has_subcomponents
        })
        
        # Add link from component group to component
        links.append({
            "source": component_data["component_group"]["id"],
            "target": component_id,
            "type": "contains"
        })
    
    # Process subcomponents according to their specific structure
    for subcomponent_id, subcomponent in subcomponent_data.items():
        parent_id = None
        
        # Check for parent reference in the subcomponent data
        if "parent" in subcomponent:
            parent_id = subcomponent["parent"]
        else:
            # Try to infer parent from name patterns
            for component_id in component_data["components"]:
                if component_id in subcomponent_id:
                    parent_id = component_id
                    break
        
        if parent_id:
            # Process capabilities based on subcomponent structure
            capabilities_list = []
            has_capabilities = False
            
            if "capabilities" in subcomponent:
                # Handle both array and object structures
                if isinstance(subcomponent["capabilities"], list):
                    capabilities_list = subcomponent["capabilities"]
                    has_capabilities = len(capabilities_list) > 0
                elif isinstance(subcomponent["capabilities"], dict) and "items" in subcomponent["capabilities"]:
                    capabilities_list = subcomponent["capabilities"]["items"]
                    has_capabilities = len(capabilities_list) > 0
            
            # Create subcomponent node
            nodes.append({
                "id": subcomponent_id,
                "name": subcomponent.get("name", subcomponent_id),
                "type": "subcomponent",
                "description": subcomponent.get("description", ""),
                "parent": parent_id,
                "level": 2,
                "expandable": has_capabilities,
                "has_children": has_capabilities
            })
            
            # Add link from component to subcomponent
            links.append({
                "source": parent_id,
                "target": subcomponent_id,
                "type": "contains"
            })
            
            # Process capabilities and create nodes/links
            for capability_idx, capability in enumerate(capabilities_list):
                if isinstance(capability, dict) and "name" in capability:
                    # Create capability ID
                    capability_id = f"{subcomponent_id}-capability-{capability.get('id', capability['name'].lower().replace(' ', '-'))}"
                    
                    # Process functions based on capability structure
                    functions_list = []
                    has_functions = False
                    
                    if "functions" in capability:
                        # Handle both array and object structures
                        if isinstance(capability["functions"], list):
                            functions_list = capability["functions"]
                            has_functions = len(functions_list) > 0
                        elif isinstance(capability["functions"], dict) and "items" in capability["functions"]:
                            functions_list = capability["functions"]["items"]
                            has_functions = len(functions_list) > 0
                    
                    # Create capability node
                    nodes.append({
                        "id": capability_id,
                        "name": capability["name"],
                        "type": "capability",
                        "description": capability.get("description", ""),
                        "parent": subcomponent_id,
                        "level": 3,
                        "expandable": has_functions,
                        "has_children": has_functions
                    })
                    
                    # Add link from subcomponent to capability
                    links.append({
                        "source": subcomponent_id,
                        "target": capability_id,
                        "type": "has_capability"
                    })
                    
                    # Process functions and create nodes/links
                    for function_idx, function in enumerate(functions_list):
                        if isinstance(function, dict) and "name" in function:
                            # Create function ID
                            function_id = f"{capability_id}-function-{function.get('id', function['name'].lower().replace(' ', '-'))}"
                            
                            # Process specifications based on function structure
                            specifications_list = []
                            has_specifications = False
                            
                            if "specifications" in function:
                                # Handle both array and object structures
                                if isinstance(function["specifications"], list):
                                    specifications_list = function["specifications"]
                                    has_specifications = len(specifications_list) > 0
                                elif isinstance(function["specifications"], dict) and "items" in function["specifications"]:
                                    specifications_list = function["specifications"]["items"]
                                    has_specifications = len(specifications_list) > 0
                                elif isinstance(function["specifications"], dict):
                                    # Handle single specification objects
                                    specifications_list = [function["specifications"]]
                                    has_specifications = True
                            
                            # Create function node
                            nodes.append({
                                "id": function_id,
                                "name": function["name"],
                                "type": "function",
                                "description": function.get("description", ""),
                                "parent": capability_id,
                                "level": 4,
                                "expandable": has_specifications,
                                "has_children": has_specifications
                            })
                            
                            # Add link from capability to function
                            links.append({
                                "source": capability_id,
                                "target": function_id,
                                "type": "has_function"
                            })
                            
                            # Process specifications and create nodes/links
                            for spec_idx, specification in enumerate(specifications_list):
                                if isinstance(specification, dict) and "name" in specification:
                                    # Create specification ID
                                    spec_id = f"{function_id}-specification-{specification.get('id', specification['name'].lower().replace(' ', '-'))}"
                                    
                                    # Process integrations based on specification structure
                                    integrations_list = []
                                    has_integrations = False
                                    
                                    # Handle single integration object or array of integrations
                                    if "integration" in specification:
                                        integrations_list = [specification["integration"]]
                                        has_integrations = True
                                    elif "integrations" in specification:
                                        if isinstance(specification["integrations"], list):
                                            integrations_list = specification["integrations"]
                                            has_integrations = len(integrations_list) > 0
                                        elif isinstance(specification["integrations"], dict) and "items" in specification["integrations"]:
                                            integrations_list = specification["integrations"]["items"]
                                            has_integrations = len(integrations_list) > 0
                                    
                                    # Create specification node
                                    nodes.append({
                                        "id": spec_id,
                                        "name": specification["name"],
                                        "type": "specification",
                                        "description": specification.get("description", ""),
                                        "parent": function_id,
                                        "level": 5,
                                        "expandable": has_integrations,
                                        "has_children": has_integrations
                                    })
                                    
                                    # Add link from function to specification
                                    links.append({
                                        "source": function_id,
                                        "target": spec_id,
                                        "type": "has_specification"
                                    })
                                    
                                    # Process integrations and create nodes/links
                                    for integration_idx, integration in enumerate(integrations_list):
                                        if isinstance(integration, dict) and "name" in integration:
                                            # Create integration ID
                                            integration_id = f"{spec_id}-integration-{integration.get('id', integration['name'].lower().replace(' ', '-'))}"
                                            
                                            # Process techniques based on integration structure
                                            techniques_list = []
                                            has_techniques = False
                                            
                                            if "techniques" in integration:
                                                if isinstance(integration["techniques"], list):
                                                    techniques_list = integration["techniques"]
                                                    has_techniques = len(techniques_list) > 0
                                                elif isinstance(integration["techniques"], dict) and "items" in integration["techniques"]:
                                                    techniques_list = integration["techniques"]["items"]
                                                    has_techniques = len(techniques_list) > 0
                                            
                                            # Create integration node
                                            nodes.append({
                                                "id": integration_id,
                                                "name": integration["name"],
                                                "type": "integration",
                                                "description": integration.get("description", ""),
                                                "parent": spec_id,
                                                "level": 6,
                                                "expandable": has_techniques,
                                                "has_children": has_techniques
                                            })
                                            
                                            # Add link from specification to integration
                                            links.append({
                                                "source": spec_id,
                                                "target": integration_id,
                                                "type": "has_integration"
                                            })
                                            
                                            # Process techniques and create nodes/links
                                            for technique_idx, technique in enumerate(techniques_list):
                                                if isinstance(technique, dict) and "name" in technique:
                                                    # Create technique ID
                                                    technique_id = f"{integration_id}-technique-{technique.get('id', technique['name'].lower().replace(' ', '-'))}"
                                                    
                                                    # Process applications based on technique structure
                                                    applications_list = []
                                                    has_applications = False
                                                    
                                                    if "applications" in technique:
                                                        if isinstance(technique["applications"], list):
                                                            applications_list = technique["applications"]
                                                            has_applications = len(applications_list) > 0
                                                        elif isinstance(technique["applications"], dict) and "items" in technique["applications"]:
                                                            applications_list = technique["applications"]["items"]
                                                            has_applications = len(applications_list) > 0
                                                    
                                                    # Create technique node
                                                    nodes.append({
                                                        "id": technique_id,
                                                        "name": technique["name"],
                                                        "type": "technique",
                                                        "description": technique.get("description", ""),
                                                        "parent": integration_id,
                                                        "level": 7,
                                                        "expandable": has_applications,
                                                        "has_children": has_applications
                                                    })
                                                    
                                                    # Add link from integration to technique
                                                    links.append({
                                                        "source": integration_id,
                                                        "target": technique_id,
                                                        "type": "has_technique"
                                                    })
                                                    
                                                    # Process applications and create nodes/links
                                                    for app_idx, application in enumerate(applications_list):
                                                        if isinstance(application, dict) and "name" in application:
                                                            # Create application ID
                                                            application_id = f"{technique_id}-application-{application.get('id', application['name'].lower().replace(' ', '-'))}"
                                                            
                                                            # Process inputs/outputs based on application structure
                                                            inputs_list = []
                                                            outputs_list = []
                                                            has_io = False
                                                            
                                                            if "inputs" in application:
                                                                if isinstance(application["inputs"], list):
                                                                    inputs_list = application["inputs"]
                                                                elif isinstance(application["inputs"], dict) and "items" in application["inputs"]:
                                                                    inputs_list = application["inputs"]["items"]
                                                            
                                                            if "outputs" in application:
                                                                if isinstance(application["outputs"], list):
                                                                    outputs_list = application["outputs"]
                                                                elif isinstance(application["outputs"], dict) and "items" in application["outputs"]:
                                                                    outputs_list = application["outputs"]["items"]
                                                            
                                                            has_io = len(inputs_list) > 0 or len(outputs_list) > 0
                                                            
                                                            # Create application node
                                                            nodes.append({
                                                                "id": application_id,
                                                                "name": application["name"],
                                                                "type": "application",
                                                                "description": application.get("description", ""),
                                                                "parent": technique_id,
                                                                "level": 8,
                                                                "expandable": has_io,
                                                                "has_children": has_io
                                                            })
                                                            
                                                            # Add link from technique to application
                                                            links.append({
                                                                "source": technique_id,
                                                                "target": application_id,
                                                                "type": "has_application"
                                                            })
                                                            
                                                            # Process inputs and create nodes/links
                                                            for input_idx, input_item in enumerate(inputs_list):
                                                                if isinstance(input_item, dict) and "name" in input_item:
                                                                    # Create input ID
                                                                    input_id = f"{application_id}-input-{input_item.get('id', input_item['name'].lower().replace(' ', '-'))}"
                                                                    
                                                                    # Create input node
                                                                    nodes.append({
                                                                        "id": input_id,
                                                                        "name": input_item["name"],
                                                                        "type": "input",
                                                                        "description": input_item.get("description", ""),
                                                                        "parent": application_id,
                                                                        "level": 9,
                                                                        "expandable": False,
                                                                        "has_children": False
                                                                    })
                                                                    
                                                                    # Add link from application to input
                                                                    links.append({
                                                                        "source": application_id,
                                                                        "target": input_id,
                                                                        "type": "has_input"
                                                                    })
                                                            
                                                            # Process outputs and create nodes/links
                                                            for output_idx, output_item in enumerate(outputs_list):
                                                                if isinstance(output_item, dict) and "name" in output_item:
                                                                    # Create output ID
                                                                    output_id = f"{application_id}-output-{output_item.get('id', output_item['name'].lower().replace(' ', '-'))}"
                                                                    
                                                                    # Create output node
                                                                    nodes.append({
                                                                        "id": output_id,
                                                                        "name": output_item["name"],
                                                                        "type": "output",
                                                                        "description": output_item.get("description", ""),
                                                                        "parent": application_id,
                                                                        "level": 9,
                                                                        "expandable": False,
                                                                        "has_children": False
                                                                    })
                                                                    
                                                                    # Add link from application to output
                                                                    links.append({
                                                                        "source": application_id,
                                                                        "target": output_id,
                                                                        "type": "has_output"
                                                                    })
    
    # Log the number of nodes and links created
    app.logger.info(f"Created {len(nodes)} nodes and {len(links)} links")
    
    return {
        "nodes": nodes,
        "links": links
    }

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/api/graph')
def graph():
    try:
        graph_data = build_graph_data()
        return jsonify(graph_data)
    except Exception as e:
        app.logger.error(f"Error generating graph data: {e}")
        return jsonify({"error": "Failed to generate graph data"}), 500

@app.route('/api/details/<node_id>')
def node_details(node_id):
    try:
        # Find details for the requested node
        component_data = get_component_data()
        subcomponent_data = get_subcomponent_data()
        
        # Check if it's the component group
        if node_id == component_data["component_group"]["id"]:
            return jsonify(component_data["component_group"])
        
        # Check if it's a component
        if node_id in component_data["components"]:
            return jsonify(component_data["components"][node_id])
        
        # Check if it's a subcomponent
        if node_id in subcomponent_data:
            return jsonify(subcomponent_data[node_id])
        
        # Check if it's a capability or other child element
        for subcomponent_id, subcomponent in subcomponent_data.items():
            if node_id.startswith(f"{subcomponent_id}-capability-"):
                capability_name = node_id.replace(f"{subcomponent_id}-capability-", "").replace("-", " ")
                if "capabilities" in subcomponent:
                    for capability in subcomponent["capabilities"]:
                        if isinstance(capability, dict) and capability["name"].lower() == capability_name:
                            return jsonify(capability)
        
        app.logger.warning(f"Node not found: {node_id}")
        return jsonify({"error": "Node not found"}), 404
    except Exception as e:
        app.logger.error(f"Error retrieving node details for {node_id}: {e}")
        return jsonify({"error": "Internal server error"}), 500

@app.route('/api/literature')
def literature():
    """Get all literature references."""
    try:
        return jsonify(get_literature_data())
    except Exception as e:
        app.logger.error(f"Error retrieving literature data: {e}")
        return jsonify({"error": "Failed to retrieve literature data"}), 500

@app.route('/api/debug')
def debug():
    """Endpoint for debugging the data structure."""
    try:
        return jsonify({
            "components": len(get_component_data()["components"]),
            "subcomponents": len(get_subcomponent_data())
        })
    except Exception as e:
        app.logger.error(f"Error in debug endpoint: {e}")
        return jsonify({"error": "Internal server error"}), 500

@app.route('/api/hierarchy-path/<node_id>')
def get_hierarchy_path(node_id):
    """Return the hierarchical path from root to the specified node."""
    node = get_node_by_id(node_id)
    if not node:
        return jsonify({"error": "Node not found"}), 404
    
    path = []
    current_node = node
    
    # Add the current node to the path
    path.append({
        "id": current_node.get("id", ""),
        "name": current_node.get("name", ""),
        "type": current_node.get("type", "")
    })
    
    # Look for parent nodes and add them to the path
    while "parent" in current_node and current_node["parent"]:
        parent_id = current_node["parent"]
        parent_node = get_node_by_id(parent_id)
        if parent_node:
            path.insert(0, {
                "id": parent_node.get("id", ""),
                "name": parent_node.get("name", ""),
                "type": parent_node.get("type", "")
            })
            current_node = parent_node
        else:
            break
    
    return jsonify({"path": path})

@app.errorhandler(404)
def not_found_error(error):
    return jsonify({"error": "Resource not found"}), 404

@app.errorhandler(500)
def internal_error(error):
    app.logger.error(f"Internal server error: {error}")
    return jsonify({"error": "Internal server error"}), 500

@app.route('/health')
def health_check():
    """Health check endpoint for monitoring."""
    return jsonify({"status": "healthy"}), 200

# For local development
if __name__ == '__main__':
    # Get port from environment or use default
    port = int(os.environ.get('PORT', 3000))
    # Use debug mode for local development only
    debug_mode = os.environ.get('FLASK_ENV') == 'development'
    
    print(f"Starting AI Alignment Visualization on http://localhost:{port}/")
    app.run(host='0.0.0.0', port=port, debug=debug_mode)
else:
    # For production WSGI servers like Gunicorn
    gunicorn_logger = logging.getLogger('gunicorn.error')
    app.logger.handlers = gunicorn_logger.handlers
    app.logger.setLevel(gunicorn_logger.level) 